<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://gyuhoonk.github.io/tag/kubernetes/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://gyuhoonk.github.io/" rel="alternate" type="text/html" />
  <updated>2025-10-11T17:32:24+09:00</updated>
  <id>https://gyuhoonk.github.io/tag/kubernetes/feed.xml</id>

  
  
  

  
    <title type="html">Gyuhoon Kim | </title>
  

  
    <subtitle>Data Engineering</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">KubernetesPodOperator에서 ApiException(400)의 발생하는 이유는?</title>
      <link href="https://gyuhoonk.github.io/pod-operator-400" rel="alternate" type="text/html" title="KubernetesPodOperator에서 ApiException(400)의 발생하는 이유는?" />
      <published>2025-10-01T22:30:00+09:00</published>
      <updated>2025-10-01T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/pod-operator-400</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/pod-operator-400">&lt;ul&gt;
  &lt;li&gt;KubernetesPodOperator 사용 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.client.exceptions.ApiException: (400)&lt;/code&gt;이 발생하는 원인에 대해서 분석합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제-상황-kubernetesclientexceptionsapiexception-400-발생&quot;&gt;문제 상황: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.client.exceptions.ApiException: (400)&lt;/code&gt; 발생&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  File &quot;/usr/local/lib/python3.12/site-packages/kubernetes/client/rest.py&quot;, line 234, in request
    raise ApiException(http_resp=r)
kubernetes.client.exceptions.ApiException: (400)
Reason: Bad Request
...
[2025-10-01, 07:21:10 KST] {pod_manager.py:365} WARNING - Pod not yet started: { pod_name }
[2025-10-01, 07:21:11 KST] {pod_manager.py:365} WARNING - Pod not yet started: { pod_name }
[2025-10-01, 07:21:42 KST] {pod.py:844} INFO - Deleting pod: { pod_name }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;cncf-kubernetes==7.13.0 사용 시 위와 같은 로그를 남기며 KubernetesPodOpeartor가 실패하는 경우가 종종 발생합니다.&lt;/li&gt;
  &lt;li&gt;항상 발생하는 것은 아니며, 간헐적으로 발생했습니다. 특히, 대부분의 경우에 task를 재실행하면 Pod이 정상적으로 생성/실행되어서 해당 현상을 재현하기 어려웠고 원인을 파악하기 힘들었습니다.&lt;/li&gt;
  &lt;li&gt;task의 실패를 최소화하기 위해 원인을 파악하고 대응해보고자 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetesclientexceptionsapiexception-400-에러의-의미&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubernetes.client.exceptions.ApiException: (400)&lt;/code&gt; 에러의 의미&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;생성된 Pod로부터 log를 읽을 수 없을 때 발생합니다.&lt;/li&gt;
  &lt;li&gt;실제로 아직 Running pahse가 아닌 Pod(Pending pod)에 대해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl logs &amp;lt;pod-name&amp;gt;&lt;/code&gt;를 실행하면 동일한 에러를 확인할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;다만, airflow에 남은 로그를 확인해보았을 때, Pod는 이미 Running 상태인 것으로 보입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pod not yet started&lt;/code&gt; 로그는 Pod Phase가 Pending일 때의 로그인 것으로 확인했고, 해당 로그가 등장하지 않으면 Running 상태인 것으로 확인했기 때문입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kubernetespodoperator는-언제-log를-가져오나&quot;&gt;KubernetesPodOperator는 언제 log를 가져오나?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;KubernetesPodOperator의 동작 방식은 대략적으로 아래와 같습니다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_or_create_pod&lt;/code&gt; : pod를 생성합니다&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await_pod_start&lt;/code&gt;: pod start를 대기합니다. 즉, pod가 Running phase가 될 때까지 대기합니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_requested_container_logs&lt;/code&gt;: Running Pod 내에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt; container로부터 log를 가져옵니다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clean_up&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deleting_pod&lt;/code&gt;: 위 과정 중에 에러가 발생하는 경우에 Pod를 삭제합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위 과정 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_requested_container_logs&lt;/code&gt;에서 문제가 발생하는 것으로 보입니다.&lt;/li&gt;
  &lt;li&gt;여기까지 보면 Running Pod 내부의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt; container의 로그를 가져오지 못했기 때문에 에러가 발생하는 것으로 볼 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;running-pod에-대해서도-apiexception400이-발생할-수-있다&quot;&gt;Running Pod에 대해서도 ApiException(400)이 발생할 수 있다&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;위에서 Pending Pod에 대해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl logs&lt;/code&gt; 명령어 실행 시 ApiException(400)이 발생한다고 말씀드렸습니다.&lt;/li&gt;
  &lt;li&gt;Running Pod에 대해서도 동일한 에러가 발생할 수 있습니다. 이는 Running Pod인 경우에 Pod 내의 모든 container가 실행 중인 상태는 아니기 때문입니다.&lt;/li&gt;
  &lt;li&gt;Pod 내에 a, b, c container를 실행한다고 가정할 때 a, b는 아직 실행되지 않아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wataing&lt;/code&gt; state이고, c만 실행되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;running&lt;/code&gt; state라면 이 Pod는 Running phase입니다.&lt;/li&gt;
  &lt;li&gt;이 때 a나 b의 log를 조회하려고 하면 ApiException(400)이 발생합니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl logs &amp;lt;pod-name&amp;gt; --container a&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참고pod-phase에-대하여&quot;&gt;[참고]Pod Phase에 대하여&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Pod는 5개의 Phase를 갖습니다.(Pending, Running, Succeeded, Failed, Unknown)
    &lt;ul&gt;
      &lt;li&gt;이 중에서 Pending, Running이 현재 발생하는 에러와 연관이 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pending Phase는 아직 Pod이 실행되지 않았고, 실행(Running)을 준비하는 단계입니다. k8s 클러스터로부터 Pod 생성이 허용되고, conatiner image를 다운로드 받습니다.&lt;/li&gt;
  &lt;li&gt;Running Phase는 실제로 Pod이 실행되는 단계입니다. Pod 내에 1개 이상의 container가 실행되고 있는 단계입니다.
    &lt;ul&gt;
      &lt;li&gt;즉, Running이라고 해서 모든 container가 running 상태는 아니라는 뜻입니다.&lt;/li&gt;
      &lt;li&gt;pod 내에 sidecar 형태로 3개의 container를 선언했고, 이 중 1개의 container라도 running에 돌입했다면 pod phase는 running이 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;에러의-원인-xcompush를-위해-추가된-airflow-xcom-sidecar&quot;&gt;에러의 원인: XComPush를 위해 추가된 airflow-xcom-sidecar&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;KubernetesPodOperator는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt; container를 생성하여 입력된 cmd, args를 실행합니다.&lt;/li&gt;
  &lt;li&gt;Pod Phase가 Running으로 돌입하면, 생성된 Pod 내에 base container의 로그를 가져오는 코드를 실행합니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_requested_container_logs&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;보통 KubernetesPodOperator를 사용하여 생성된 Pod은 base container 1개만 실행합니다(init container가 완료된 후 실행되는 container는 1개).&lt;/li&gt;
  &lt;li&gt;그러나 XCom Push를 사용하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_xcom_push=True&lt;/code&gt; 옵션을 주면 base conatiner 외에 xcom push을 위한 컨테이너(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;airflow-xcom-sidecar&lt;/code&gt;)를 생성합니다(=Side Car 패턴)&lt;/li&gt;
  &lt;li&gt;해당 컨테이너는 base container의 작업이 완료되어도 volume이 삭제되지 않도록 유지하는 역할을 합니다. base conatiner의 작업이 종료되어도 XComPush path(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/airflow/xcom/return.json&lt;/code&gt;)에 대한 volume mount를 유지하여 airflow worker에서 해당 값을 참조할 수 있도록 하는 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;해당 컨테이너는 가벼운 docker image(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alpine&lt;/code&gt;)를 사용하기 때문에 base conatiner에 비해 더 빠르게 시작됩니다.&lt;/li&gt;
  &lt;li&gt;위의 Pod Phase를 다시 보면, Pod의 Running Phase는 Pod 내의 N개의 container 중 1개의 container라도 running인 경우입니다.&lt;/li&gt;
  &lt;li&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;airflow-xcom-sidecar&lt;/code&gt;는 running, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt;는 waiting인 상태에서도 Pod Phase는 Running으로 돌입합니다.&lt;/li&gt;
  &lt;li&gt;이렇게 되면 airflow는 base container의 log를 조회할 수 있다고 판단하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_requested_container_logs&lt;/code&gt; 함수를 실행합니다.&lt;/li&gt;
  &lt;li&gt;하지만 base conatiner가 아직 실행되지 않은 상태이기 때문에 존재하지 않는 container로의 요청이므로 400 error(Bad Request)가 발생합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;providers-cncf-kubernetes1082에서의-변화&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;providers-cncf-kubernetes==10.8.2&lt;/code&gt;에서의 변화&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Kubernetes는 init container를 제외하면 container들 간의 실행 순서(시작 순서)를 제어할 수 있는 방법은 제공하지 않습니다.&lt;/li&gt;
  &lt;li&gt;혹은 특정 container가 running일 때 Pod가 Running Phase에 돌입한다던가 하는 방법도 존재하지 않습니다.&lt;/li&gt;
  &lt;li&gt;따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_requested_container_logs&lt;/code&gt;가 실행되기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;await_pod_start&lt;/code&gt;를 수정하는 것이 적합한 방향입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;## cncf/kubernetes/utils/pod_manager.py (apache-airflow-providers-cncf-kubernetes==7.13.0)
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;await_pod_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V1Pod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startup_timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startup_check_interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
        Wait for the pod to reach phase other than ``Pending``.

        :param pod:
        :param startup_timeout: Timeout (in seconds) for startup of the pod
            (if pod is pending for too long, fails task)
        :param startup_check_interval: Interval (in seconds) between checks
        :return:
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curr_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;remote_pod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_pod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remote_pod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PodPhase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PENDING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;## &amp;lt;- PodPhase를 기준으로 판단하고 있음
&lt;/span&gt;                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;warning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Pod not yet started: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startup_timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Pod took longer than &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startup_timeout&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; seconds to start. &quot;&lt;/span&gt;
                    &lt;span class=&quot;s&quot;&gt;&quot;Check the pod events in kubernetes to determine why.&quot;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PodLaunchFailedException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startup_check_interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;최신 버전(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;providers-cncf-kubernetes==10.8.2&lt;/code&gt;)에서는 아래와 같이 container state를 확인하는 &lt;a href=&quot;https://github.com/apache/airflow/blob/providers-cncf-kubernetes/10.8.2/providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py#L445&quot;&gt;코드&lt;/a&gt;가 추가되었습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pod_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container_statuses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container_status&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pod_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container_statuses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;container_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V1ContainerState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container_status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;container_waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V1ContainerStateWaiting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container_waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container_waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reason&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ErrImagePull&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;InvalidImageName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
                        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;::endgroup::&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PodLaunchFailedException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                            &lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Pod docker image cannot be pulled, unable to start: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container_waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reason&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
                            &lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;container_waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
                        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Pod 내에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;waiting&lt;/code&gt; state인 container에 대해서 Image 관련 에러가 발생하는 경우 조기에 실패시키는 코드입니다.&lt;/li&gt;
  &lt;li&gt;그러나 여전히 Pod Phase에 의존하는 방식은 변경되지 않았습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base container가 시작되지 않음&lt;/code&gt; = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용하는 docker image pull에 문제가 있음&lt;/code&gt;으로 판단하는 것 같습니다.&lt;/li&gt;
  &lt;li&gt;클러스터 내 자원(CPU, memory)을 할당받지 못해 base conatiner가 늦게 시작되는 경우에 대해서는 감지하지 않는 것으로 보입니다.&lt;/li&gt;
  &lt;li&gt;즉 여전히 ApiException(400)은 발생할 가능성이 있어 보입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;base-conatiner가-waiting인-경우에-대해서의-감지를-추가하기&quot;&gt;base conatiner가 waiting인 경우에 대해서의 감지를 추가하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(작성 중)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_xcom_push=True&lt;/code&gt; 사용 시 Pod Phase와 base container state의 불일치로 인해 해당 에러가 발생할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase&quot;&gt;Pod Phase&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="airflow" />
      
        <category term="kubernetes" />
      

      
        <summary type="html">KubernetesPodOperator 사용 시 kubernetes.client.exceptions.ApiException: (400)이 발생하는 원인에 대해서 분석합니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ConfigMap과 Secret의 차이점</title>
      <link href="https://gyuhoonk.github.io/configmap-secret" rel="alternate" type="text/html" title="ConfigMap과 Secret의 차이점" />
      <published>2025-03-15T22:30:00+09:00</published>
      <updated>2025-03-15T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/configmap-secret</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/configmap-secret">&lt;p&gt;ConfigMap과 Secret은 뭐가 다른걸까?&lt;/p&gt;

&lt;h2 id=&quot;면접&quot;&gt;면접&lt;/h2&gt;

&lt;h2 id=&quot;kubectl에서의-차이점&quot;&gt;kubectl에서의 차이점&lt;/h2&gt;

&lt;h2 id=&quot;secret은-민감-정보에-사용된다-왜&quot;&gt;Secret은 민감 정보에 사용된다. 왜?&lt;/h2&gt;

&lt;h2 id=&quot;etcd-암호화&quot;&gt;etcd 암호화&lt;/h2&gt;

&lt;h2 id=&quot;요약&quot;&gt;요약&lt;/h2&gt;

&lt;p&gt;[참고]&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="kubernetes" />
      

      
        <summary type="html">ConfigMap과 Secret은 뭐가 다른걸까?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">multi-stage와 Builder Pattern</title>
      <link href="https://gyuhoonk.github.io/multi-stage-and-builder-pattern" rel="alternate" type="text/html" title="multi-stage와 Builder Pattern" />
      <published>2023-06-10T22:30:00+09:00</published>
      <updated>2023-06-10T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/multi-stage-and-builder-pattern</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/multi-stage-and-builder-pattern">&lt;p&gt;DataHub로 알아본 Docker build 전략 (multi-stage, Builder pattern)&lt;/p&gt;

&lt;h3 id=&quot;multi-stage-build&quot;&gt;multi-stage build&lt;/h3&gt;

&lt;p&gt;multi stage build는 2개 이상의 베이스 이미지를 이용합니다. 하나의 이미지 A에서는 빌드를 하고 빌드 결과물을 다른 이미지 B로 COPY합니다.
Docker 공식 문서에서 제공하고 있는 예시를 살펴보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-Dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# syntax=docker/dockerfile:1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; golang:1.16 AS builder&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /go/src/github.com/alexellis/href-counter/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;go get &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; golang.org/x/net/html  
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; app.go ./&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;CGO_ENABLED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 go build &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-installsuffix&lt;/span&gt; cgo &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; app .

&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; alpine:latest  &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apk &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; add ca-certificates
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /root/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; --from=builder /go/src/github.com/alexellis/href-counter/app ./&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;./app&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; alexellis2/href-counter:latest &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;builder&lt;/code&gt;로 네이밍한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;golang:1.16&lt;/code&gt;은 빌드를 실행(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go build&lt;/code&gt;)하고 빌드 결과물(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/go/src/github.com/alexellis/href-counter/app&lt;/code&gt;)을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alpine:latest&lt;/code&gt;로 복사합니다.&lt;br /&gt;
이는 기존의 Builder pattern의 단점을 보완했습니다. Builder pattern이란 2개의 Dockerfile을 이용하는 방법입니다.&lt;/p&gt;

&lt;h3 id=&quot;builder-pattern&quot;&gt;Builder pattern&lt;/h3&gt;

&lt;p&gt;Builder pattern은 production image(배포용 이미지)의 레이어를 최소화(slimmed-down)하기 위해 제안되었습니다. 개발용 이미지와 배포용 이미지를 분리합니다. 즉, 개발용 이미지에서는 어플리케이션을 개발하고 빌드하기 위한 모든 이미지를 포함하지만, 배포용 이미지에서는 어플리케이션과 어플리케이션을 실행하기 위한 의존성만을 포함합니다.&lt;/p&gt;

&lt;p&gt;아래 예시에서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build.Dockerfile&lt;/code&gt;은 개발용 이미지이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;은 배포용 이미지입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build.Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-Dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# syntax=docker/dockerfile:1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; golang:1.16&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /go/src/github.com/alexellis/href-counter/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; app.go ./&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;go get &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; golang.org/x/net/html &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;CGO_ENABLED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 go build &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-installsuffix&lt;/span&gt; cgo &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; app .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-Dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# syntax=docker/dockerfile:1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; alpine:latest  &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apk &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; add ca-certificates
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /root/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; app ./&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;./app&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기존 Builder pattern에서는 위 2개의 도커파일(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build.Dockerfile, Dockerfile&lt;/code&gt;)을 차례로 실행합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;Building alexellis2/href-counter:build
docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; alexellis2/href-counter:build &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; build.Dockerfile

docker container create &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt; extract alexellis2/href-counter:build  
docker container &lt;span class=&quot;nb&quot;&gt;cp &lt;/span&gt;extract:/go/src/github.com/alexellis/href-counter/app ./app  
docker container &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; extract

&lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;Building alexellis2/href-counter:latest
docker build &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; alexellis2/href-counter:latest &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; ./app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;첫번째 이미지(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build.Dockerfile&lt;/code&gt;)를 빌드한다&lt;/li&gt;
  &lt;li&gt;첫번째 빌드에서 실행된 컨테이너에서 빌드 결과물(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app&lt;/code&gt;)을 로컬로 복사한다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker container cp&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;두번째 이미지를 빌드하면, 로컬에 복사된 결과물을 컨테이너 내부로 가져온다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 방법으로 빌드된 배포용 이미지는 최소한의 레이어만을 포함합니다. 즉, 배포에 더 용이합니다.
그러나 아래와 같은 단점을 갖습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2개의 빌드 파일을 작성해야한다(빌드용 이미지와 빌드 결과물을 옮길 최종 결과물 이미지)&lt;/li&gt;
  &lt;li&gt;빌드 과정에서 사용해야하는 커맨드가 많다(컨테이너 내부에 접속하여 결과물을 로컬로 옮겨야한다)&lt;/li&gt;
  &lt;li&gt;로컬 환경에 빌드 결과물이 남는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;datahub-v010-이전의-빌드-전략-multi-stage-build&quot;&gt;DataHub v0.10 이전의 빌드 전략: multi-stage build&lt;/h3&gt;
&lt;p&gt;v0.10 이전 DataHub는 docker 빌드 시 mutl-stage build를 이용했습니다.&lt;/p&gt;

&lt;p&gt;아래는 v0.8.40에서 datahub-gms를 빌드하는 Dockerfile의 일부입니다(&lt;a href=&quot;https://github.com/acryldata/datahub/blob/v0.8.40/docker/datahub-gms/Dockerfile&quot;&gt;docker/datahub-gms/Dockerfile&lt;/a&gt;).&lt;/p&gt;

&lt;div class=&quot;language-docker highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; --platform=$BUILDPLATFORM alpine:3.14 AS prod-build&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Upgrade Alpine and base packages&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;apk &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--update-cache&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--available&lt;/span&gt; upgrade &lt;span class=&quot;se&quot;&gt;\
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apk &lt;span class=&quot;nt&quot;&gt;--no-cache&lt;/span&gt; add openjdk8 perl

&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; . /datahub-src&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /datahub-src &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; ./gradlew :metadata-service:war:build &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; /datahub-src/metadata-service/war/build/libs/war.war /war.war

&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; base as prod-install&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; --from=prod-build /war.war /datahub/datahub-gms/bin/war.war&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prod-build&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;war.war&lt;/code&gt;를 빌드한다.&lt;/li&gt;
  &lt;li&gt;빌드 결과를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prod-install&lt;/code&gt;로 COPY한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;multi-stage build 방식을 이용하기 때문에 위 Dockerfile을 실행할 때 로컬에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;war.war&lt;/code&gt;는 남지 않습니다. 또한 builder pattern처럼 여러 개의 도커 커맨드를 실행할 필요가 없었습니다.&lt;/p&gt;

&lt;h3 id=&quot;datahub-v0100의-빌드-전략-copy-from-local&quot;&gt;DataHub v0.10.0의 빌드 전략: COPY from Local&lt;/h3&gt;

&lt;p&gt;그러나 v0.10.0 이후 DataHub는 multi-stage build 전략을 버렸습니다. 따져보자면 Builder Pattern에 가까운 빌드 전략을 채택했습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prod-build&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;war.war&lt;/code&gt;를 빌드했던 스텝을 없애고 로컬에 있는 빌드 결과물인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;war.war&lt;/code&gt;를 컨테이너 내부로 COPY하고 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-docker highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; base as prod-install&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;COPY&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; war.war /datahub/datahub-gms/bin/war.war&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;따라서 Dockerfile을 실행하기 전에 사용자는 먼저 로컬에서 빌드를 수행해야합니다. 아래와 같은 명령어를 순서대로 실행해야합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./gradlew :metadata-service:war:build
docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; datahub-gms:v0.10.0 &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Dockerfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 커밋에서는 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Docker build externalized&lt;/code&gt;라고 표현합니다. 
&lt;img src=&quot;../../assets/built/images/kubernetes/docker-build-externalized.png&quot; alt=&quot;docker-build-externalized&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5번째 줄을 보면 해당 m1에서의 빌드속도가 7분 이하로 매우 빨라졌다고 설명하고 있습니다. 제 기억이 맞다면 v0.8.40에서 빌드 시 걸리는 속도가 20분 정도였으니 속도가 매우 빨라진 것은 맞는 것 같습니다.&lt;/p&gt;

&lt;p&gt;왜 이런 선택을 했을까요? 위와 같은 제안이 처음 등장한 것은 아래 PR입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/datahub-project/datahub/pull/6726&quot;&gt;run java build in action runners instead of within Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;해당 PR은 Dockerfile로 빌드를 실행할 때, local build(ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./gradlew :metadata-service:war:build&lt;/code&gt;)가 먼저 실행될 수 있도록 각 모듈별로 빌드 커맨드를 추가하고, docker 내부에서 빌드하는 부분(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prod-build&lt;/code&gt;)을 빼자고 제안합니다.&lt;/p&gt;

&lt;p&gt;이 제안을 받아들여 david는 GHA(GitHub Actions)에서 소스코드 빌드 &amp;amp; 도커 빌드가 동시에 실행될 수 있도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;도 함께 수정한 것으로 보입니다.&lt;/p&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;multi-stage build는 Builder Pattern에 비해 Dockerfile 작성과 실행이 간단하다.&lt;/li&gt;
  &lt;li&gt;Builder Pattern은 필요한 최소의 레이어만 배포하므로 가볍다.&lt;/li&gt;
  &lt;li&gt;필요에 따라 multi-stage build와 Builder Pattern 중에 선택하여 Dockerfile을 작성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://github.com/datahub-project/datahub/pull/6744&quot;&gt;datahub PR#6744&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/datahub-project/datahub/pull/6726&quot;&gt;datahub PR#6726&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.docker.com/build/building/multi-stage/&quot;&gt;multi-stage&lt;/a&gt;
&lt;a href=&quot;https://blog.alexellis.io/mutli-stage-docker-builds/&quot;&gt;Builder pattern vs. Multi-stage builds in Docker&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="kubernetes" />
      

      
        <summary type="html">DataHub로 알아본 Docker build 전략 (multi-stage, Builder pattern)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pod와 Container</title>
      <link href="https://gyuhoonk.github.io/pod-container" rel="alternate" type="text/html" title="Pod와 Container" />
      <published>2023-02-12T22:30:00+09:00</published>
      <updated>2023-02-12T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/pod-container</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/pod-container">&lt;p&gt;Container와 Pod의 기본개념을 확인해봅니다.&lt;/p&gt;

&lt;h2 id=&quot;container란-무엇인가&quot;&gt;Container란 무엇인가?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;컨테이너는 소프트웨어 서비스를 실행하는 데 필요한 특정 버전의 프로그래밍 언어 런타임 및 라이브러리와 같은 종속 항목과 애플리케이션 코드를 함께 포함하는 경량 패키지입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;컨테이너는 운영체제 수준에서 CPU, 메모리, 스토리지, 네트워크 리소스를 쉽게 공유할 수 있게 해주며 컨테이너가 실제로 실행되는 환경에서 애플리케이션을 추상화할 수 있는 논리 패키징 메커니즘을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;구글 클라우드는 컨테이너에 대해 위와 같이 설명합니다. 짧은 두 문장이지만, 컨테이너는 결국 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경량 패지키&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리 패키징 메커니즘&lt;/code&gt;라는 것 같습니다. 구체적으로 어떤 뜻일까요? 컨테이너를 활용하게되면, 개발자는 제공되는 컨테이너에서 애플리케이션을 개발하고, 배포합니다. 컨테이너에는 개발자에게 프로그래밍 언어, 런타임, 라이브러리와 같은 개발 환경이 이미 셋팅(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경량 패키지&lt;/code&gt;)되어있습니다. 따라서 개발자는 이러한 개발 환경 셋팅과 디버깅 과정을 생략하고 애플리케이션 자체에 집중할 수 있습니다. 따라서 컨테이너에 대한 위 설명은 ‘개발과 배포를 하기 위해 필요한 모든 것을 준비해 놓았다!’ 정도로 이해할 수 있을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;conatiner가-개발자에게-주는-장점&quot;&gt;Conatiner가 개발자에게 주는 장점&lt;/h3&gt;
&lt;p&gt;대부분의 개발 프로세스가 오픈 소스 기반으로 이루어지고 있는 지금의 개발 환경에서, 이러한 컨테이너 기반의 개발은 매우 혁명적이었습니다. 컨테이너 기반의 개발 작업이 오픈 소스 기반 개발의 단점을 보완해줄 수 있었기 때문입니다.&lt;/p&gt;

&lt;p&gt;오픈 소스를 기반으로 하는 애플리케이션 개발은 개발자가 직접 작성해야하는 코드의 양을 줄여 개발 생산성을 늘려주었습니다. 덕분에 개발자는 단기간에 높은 수준의 애플리케이션을 만들어낼 수 있었습니다. 그러나 오픈 소스를 기반 개발은 &lt;strong&gt;버전 관리&lt;/strong&gt;라는 맹점이 존재합니다. 사용하는 오픈 소스 라이브러리의 버전업이 개발한 애플리케이션에 어떤 영향을 줄 지 예상이 불가능했고, 이는 다양한 버그와 호환성 문제를 야기했습니다. 즉 개발 생산성을 높이는 대신 애플리케이션의 안정성이 떨어지는 트레이드 오프가 발생했습니다.&lt;/p&gt;

&lt;p&gt;컨테이너는 오픈소스 기반 애플리케이션 개발의 불안정성을 보완해주었습니다. 같은 컨테이너 내에서는 제공되는 언어, 런타임, 라이브러리, 종속 항목들이 고정되어 있으므로 애플리케이션 빌드나 배포 시에 오픈 소스 라이브러리의 버전업이나 수정, 패치에 영향받지 않습니다.&lt;/p&gt;

&lt;p&gt;또한 컨테이너가 제공되고, 실행만 가능하다면 개인 노트북을 포함한 어떤 환경에서도 동일한 개발환경을 유지한 채 개발작업을 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이외에도 컨테이너는 개발자와 인프라 운영팀의 책임을 분명히 구분해주는 책임 분리(Separation of responsibility), 실해되는 다른 애플리케이션으로부터 영향을 받지 않는 애플리케이션 격리라는 장점을 갖습니다.&lt;/p&gt;

&lt;h2 id=&quot;pod란-무엇인가&quot;&gt;Pod란 무엇인가?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;파드(Pod) 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.&lt;br /&gt;
파드 (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의 컨테이너의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고, 함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는 애플리케이션 별 “논리 호스트”를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의 애플리케이션 컨테이너가 포함된다. 클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;애플리케이션 컨테이너와 마찬가지로, 파드에는 파드 시작 중에 실행되는 초기화 컨테이너가 포함될 수 있다. 클러스터가 제공하는 경우, 디버깅을 위해 임시 컨테이너를 삽입할 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kubernetes 공식문서에서는 Pod를 위와 같이 설명합니다. 요약해보자면, Pod를 아래와 같은 특징으로 요약될 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;파드는 쿠버네티스에서 생성/관리 가능한 가장 작은 컴퓨팅 단위이다&lt;/li&gt;
  &lt;li&gt;파드의 콘텐츠는 함께 배치, 스케줄, (공유 콘텍스트에서)실행된다&lt;/li&gt;
  &lt;li&gt;파드는 애플리케이션 별로 논리 호스트를 모델링한다&lt;/li&gt;
  &lt;li&gt;파드에는 초기화 컨테이너, 임시 컨테이너를 삽입할 수 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;각 항목에 대해서 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;가장-작은-컴퓨팅-단위&quot;&gt;가장 작은 컴퓨팅 단위&lt;/h3&gt;
&lt;p&gt;실제로 애플리케이션이 실행되는 것은 파드 내에 존재하는 컨테이너(Container)이지만, 쿠버네티스는 직접 컨테이너를 실행하지 않고, 파드를 실행합니다. 쿠버네티스에 의해 실행된 파드가 파드 내의 컨테이너를 관리합니다. 즉, 쿠버네티스 자체는 컨테이너에 직접적으로 관여하지 않습니다. 대신 컨트롤러(controller)를 이용하여 파드를 관리합니다.&lt;br /&gt;
한편, 파드는 LivenessProbe, ReadienessProbe를 설정하여 파드 내부의 컨테이너에서 실행되는 애플리케이션의 상태를 모니터링합니다.&lt;/p&gt;

&lt;h3 id=&quot;파드의-콘텐츠는-배치-스케줄-콘텍스트를-공유&quot;&gt;파드의 콘텐츠는 배치, 스케줄, 콘텍스트를 공유&lt;/h3&gt;
&lt;p&gt;동일 파드 내에서 실행되는 컨테이너들은 모두 같은 노드에서 실행되며, 동일 파드에 의해 관리되는 여러 컨테이너들은 동일한 리소스 및 로컬 네트워크를 공유합니다. 따라서 파드 내 컨테이너들은 분리되어 실행되더라도 통신과 리소스 공유가 가능합니다. 공유 컨텍스트(shared context)란 동일 파드 내 컨테이너 간에는 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 통신이 가능하고, 볼륨 마운트(Volume Mount)를 통하여 파일 시스템을 공유할 수 있음을 의미하는 것으로 보입니다.&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-별로-논리-호스트를-모델링&quot;&gt;애플리케이션 별로 논리 호스트를 모델링&lt;/h3&gt;
&lt;p&gt;추상적인 단어가 많아 이해하기가 어려운 개념이었습니다. 일단 원문을 다시 읽어보았습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Pod models an application-specific “logical host”: it contains one or more application containers which are relatively tightly coupled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쿠버네티스 문서에서 제공하는 번역이 원문의 의미를 전달하지 못하고 있는 것 같습니다. 몇 가지 단어를 중심으로 의미를 풀어보고자 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aplication-specific&lt;/code&gt;이란 특정 어플리케이션을 위해서 작성되었다는 의미입니다(&lt;a href=&quot;https://en.wiktionary.org/wiki/application-specific&quot;&gt;application-specific&lt;/a&gt;). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션 별로&lt;/code&gt;로 번역되어 그 의미가 정확히 전달되지 못한 것 같습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리 호스트&lt;/code&gt;로 번역된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logical host&lt;/code&gt;는 어플리케이션을 실행을 위해 필요로 하는 소프트웨어와 컴포넌트를 갖추고 있는 환경 자체를 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 두 가지 의미를 합쳐보면, Pod는 어플리케이션을 위해 작성된, 어플리케이션을 실행할 수 있는 환경 그 자체라고 해석할 수 있습니다. 나아가, Pod는 한 가지 어플리케이션만 실행하는 것이 아니라, 서로 관련 있는 여러 개의 어플리케이션을 포함할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;초기화-컨테이너-임시-컨테이너&quot;&gt;초기화 컨테이너, 임시 컨테이너&lt;/h3&gt;
&lt;p&gt;Pod에는 초기화만을 담당하는 컨테이너를 설정할 수 있습니다. 이를 초기화 컨테이너(initContainer)라고 부르며 해당 컨테이너는 Pod 시작 후에 가장 먼저 시작되어 초기화 작업을 수행하고 이후 메인 컨테이너들이 실행됩니다. 이외에도 디버깅을 위해 임시 컨테이너(Ephemeral Container)를 설정할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;위의 4가지 특징 이외에도 Pod는 아래 특징을 가지고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;pod는-일시적인-존재&quot;&gt;Pod는 일시적인 존재&lt;/h3&gt;
&lt;p&gt;Pod는 일시적인 존재로 설계되어 Pod 내의 컨테이너는 이미지로부터 매번 생성되빈다. 따라서 같은 오브젝트 이름으로 재기동하여도, 이전 컨테이너의 실행기록(로그), 변경 사항은 남지 않고 초기 이미지 상태에서부터 재실행됩니다.&lt;br /&gt;
또한 Pod의 IP도 고정적이지 않습니다. Pod의 IP는 생성과 함께 부여된 뒤, 종료 시에 회수됩니다. 재시작하더라도 같은 IP를 부여하지 않습니다. 따라서 Pod에게 요청(request)를 보내고자 하는 경우에는 반드시 service를 이용하여 고정 IP를 제공해야합니다.&lt;/p&gt;

&lt;h2 id=&quot;controller&quot;&gt;Controller&lt;/h2&gt;
&lt;p&gt;이러한 Pod는 워크로드 리소스(컨트롤러)에 의해 생성되고 관리됩니다. 컨트롤러는 파드 장애 시 복제 및 롤아웃과 자동복구를 처리합니다. 어떤 노드에서 장애가 발생했을 때, 컨트롤러는 장애 노드에서 실행되는 Pod들의 작동 중지를 인식하고, 다른 노드에서 대체 Pod를 생성하는 식으로 대응합니다. 이러한 컨트롤러에는 7가지가 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Deployment 디플로이먼트&lt;/li&gt;
  &lt;li&gt;ReplicaSet 레플리카셋&lt;/li&gt;
  &lt;li&gt;StatefultSet 스테이트풀셋&lt;/li&gt;
  &lt;li&gt;DaemonSet 데몬셋&lt;/li&gt;
  &lt;li&gt;Job 잡&lt;/li&gt;
  &lt;li&gt;CronJob 크론잡&lt;/li&gt;
  &lt;li&gt;ReplicationController 레플리케이션 컨트롤러&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Deployment의 템플릿 예시는 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# 여기서부터 파드 템플릿이다&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:1.14.2&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;# 여기까지 파드 템플릿이다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단하게 컨테이너와 파드의 개념에 대해 정리해보았고, 파드를 관리하는 컨트롤러가 무엇이 있는지까지만 알아보았습니다.&lt;br /&gt;
읽어주셔서 감사합니다 (_ _)&lt;/p&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/learn/what-are-containers?hl=ko&quot;&gt;GCP 컨테이너란?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/workloads/pods/&quot;&gt;Kubernetes 파드&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.redhat.com/ko/topics/containers/what-is-kubernetes-pod&quot;&gt;RedHat 쿠버네티스 포드(Kubernetes pod)란?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.yes24.com/Product/Goods/93317828&quot;&gt;15단계로 배우는 도커와 쿠버네티스&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="kubernetes" />
      

      
        <summary type="html">Container와 Pod의 기본개념을 확인해봅니다.</summary>
      

      
      
    </entry>
  
</feed>
