<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://gyuhoonk.github.io/author/GyuhoonK/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://gyuhoonk.github.io/" rel="alternate" type="text/html" />
  <updated>2023-03-12T23:32:49+09:00</updated>
  <id>https://gyuhoonk.github.io/author/GyuhoonK/feed.xml</id>

  
  
  

  
    <title type="html">Gyuhoon Kim | </title>
  

  
    <subtitle>Data Engineering</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Load Average란?(chagGPT로 알아보기)</title>
      <link href="https://gyuhoonk.github.io/load-avg" rel="alternate" type="text/html" title="Load Average란?(chagGPT로 알아보기)" />
      <published>2023-03-11T22:30:00+09:00</published>
      <updated>2023-03-11T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/load-avg</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/load-avg">&lt;p&gt;chatGPT로 load average로 파헤쳐보기&lt;/p&gt;

&lt;h3 id=&quot;load-average-알람과의-첫만남&quot;&gt;Load Average 알람과의 첫만남&lt;/h3&gt;
&lt;p&gt;저는 네이버웹툰에서 데이터 엔지니어로서 근무 중입니다. 데이터 엔지니어의 업무 중 하나가 데이터마트를 생성하고 주기적으로 데이터마트가 잘 업데이트되도록 하는 것입니다. 어느날 새로운 데이터마트를 생성해야했었고, 꽤 과거의 기간부터 현재까지의 데이터를 단기간에 적재해야했습니다.&lt;br /&gt;
예를 들어, 2010년 1월 1일부터 현재인 2023년 3월까지의 데이터를 일간 단위(daily)로 적재해야한다면 10년이 넘는, 즉 3650일(회) 이상의 배치 작업을 짧은 기간에 수행해야합니다.&lt;br /&gt;
이런 배치를 수행하는 과정에서 Load Average 알람을 처음 접하게 되었습니다. 해당 배치를 실행하는 서버의 Load average가 임계치를 넘어섰으니 적절한 조치를 취해야한다는 내용이었습니다.&lt;/p&gt;

&lt;h3 id=&quot;load-average가-뭐지&quot;&gt;Load Average가 뭐지?&lt;/h3&gt;
&lt;p&gt;해당 알람을 받았지만.. 사실 Load Average가 무엇인지 정확히 몰랐습니다. 서버 구동 시에 관리되는 메트릭이구나, 일정 임계치를 넘어서면 문제가 되는구나, 지금 내가 실행한 작업에 의해 영향이 있을 수 있겠구나 정도만 파악했고 제 작업을 잠시 중단하니 Load Average가 낮아졌습니다.&lt;br /&gt;
서버에서 구동 중인 작업(process)와 연관이 있겠구나 정도만 파악을 했고 정확히 알아보기 위해 검색을 시작했습니다. 운영체제를 좀 더 열심히 공부할 걸 하는 후회와 함께…
그러다가 요즘 무엇인가 공부를 하는데에 chatGPT가 효율적이란 후기들이 생각났고 저도 chagGPT한테 load average에 대해서 물어봤습니다.&lt;/p&gt;

&lt;h3 id=&quot;chatgpt야-load-average가-뭐야&quot;&gt;chatGPT야, Load Average가 뭐야?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/linux/chatgpt1.png&quot; alt=&quot;image&quot; /&gt; 
chatGPT는 깔끔하게 답변해주어서 읽는 것만으로도 대강 어떤 내용인지 이해를 할 수 있었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;현재 시스템이 얼마나 많은 작업을 수행하는지를 판단하기 위한 지표로서 활용된다.&lt;/li&gt;
  &lt;li&gt;1분, 5분, 15분으로 나누어 실행 중이거나 실행 대기 중인 프로세스의 평균 수를 나타낸다.&lt;/li&gt;
  &lt;li&gt;로드 평균이 1.0이면 완전 과부하 상태이므로 문제가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구체적인 예시와 함께 해당 내용을 이해하고 싶었습니다. 이번엔 이렇게 질문했습니다.
&lt;img src=&quot;../../assets/built/images/linux/chatgpt2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;load average의 값이 갖는 의미를 좀 더 자세히 설명해주었고, load average가 높아질 수 있는 경우에 대해서도 설명해주었습니다.&lt;/p&gt;

&lt;p&gt;첫번째 답변에서 load average가 1이라면, &lt;strong&gt;완전 과부하 상태&lt;/strong&gt;라고 했는데 두번째 답변에서는 ‘load average가 1일 수도 있고, 4인 경우가 있을 수도 있다’고 설명했고, 이건 완전 과부하 상태와 전혀 관련 없다는 듯이 설명했습니다. 이 부분이 이해가 가지 않아 다시 질문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/linux/chatgpt3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;load average가 1이라면 오히려 정상 작동하고 있을 가능성이 높다고 설명합니다. 그 이유는 CPU 코어가 1개, 2개, 4개인 경우를 생각해보았을 때 각각 CPU 사용률이 100%, 50%, 25%이기 때문이라고 말합니다. &lt;br /&gt;
여기서 조금 헷갈렸지만 다시 생각해보니 chatGPT가 조금 불친절해도 틀린 말은 하지 않았다는 걸 깨달았습니다. CPU 코어가 1개인 경우는 요즘에는 거의 없습니다. 제가 알람을 받았던 서버의 CPU도 24 core CPU였습니다. 24 core CPU에서 load average가 1이라면 CPU를 약 4% 정도만 사용하는 상태입니다. 따라서 대부분의 경우에 load average가 1인 것은 시스템이 정상일 확률이 높다는 설명입니다.&lt;br /&gt;
더불어, chatGPT의 첫번째 답변은 1 core CPU를 상정하고 답변했던 것으로 보입니다. 1 core CPU에서 load average가 1이라면 100%로 사용 중이므로 시스템이 비정상적으로 작동할 것이기 때문입니다.&lt;/p&gt;

&lt;p&gt;저의 이런 생각이 맞는지 확인하기 위해 구체적인 예시로 chagGPT에게 다시 질문했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/linux/chatgpt4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;load average에 대해 제가 생각했던 것이 맞았음을 알 수 있었습니다.&lt;/p&gt;

&lt;p&gt;이번엔 구체적으로 load average가 어떻게 계산되는지 알아보고, 직접 제 맥북에 적용하여 계산해보고자 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/linux/chatgpt5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;chatGPT에 따르면, 로드 평균을 계산하기 위해서 대기 중인 프로세스 수, 실행 중인 프로세스 수, CPU 코어 개수를 알아야합니다. 참고로 현재 제 맥북의 CPU 코어수는 10입니다. 계산을 위해서 프로세스 수를 확인하면 될 것 같습니다. 해당 명령어도 chatGPT에게 물어보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/linux/chatgpt6.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;top&lt;/code&gt; 명령어를 사용해서 프로세스 개수를 확인해보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/linux/top.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;총 프로세스 개수가 582개이고, 580개가 sleeping(대기), 2개가 running(실행)인 상태였습니다. 그런데 chatGPT에 따르면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행 중인 프로세스 수=실행 중인 프로세스 수+실행 중인 스레드 수&lt;/code&gt;입니다. 따라서, 현재 실행 중인 스레드 수인 2934도 load average 계산에 포함해야합니다. &lt;br /&gt;
그런데 이렇게 계산하면 (582+2394)/10=297.6으로 터무니없는 값이 나옵니다. 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;top&lt;/code&gt; 명령어로 확인되는 load average(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.92 3.99 4.07&lt;/code&gt;)과도 거의 100배 가까이 차이가 납니다.&lt;/p&gt;

&lt;p&gt;이 이후부터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;top&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uptime&lt;/code&gt; 명령어를 사용해가며 확인한 값(프로세스 수와 실제로 표시되는 load avg)을 chagGPT에 제공하며 실제로 load average가 어떻게 계산되는지 확인하려고 했지만 제가 의도한 답변을 받을 수 없었습니다. 그래서 포기하고, 이번엔 제가 직접 구글링해보았습니다.&lt;/p&gt;

&lt;h3 id=&quot;kernel에서-계산하는-load-avg&quot;&gt;kernel에서 계산하는 load avg&lt;/h3&gt;
&lt;p&gt;실제로 커널에서 load average를 계산하는 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc_load()&lt;/code&gt;라는 함수입니다. 
kernel 2.0.40의 함수가 가장 간단한 형태라 이해하기 편할 것 같아 예시로 가져와보았습니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// kernel/sched.c&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calc_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* fixed-point */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_FREQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ticks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_FREQ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;active_tasks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_active_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;CALC_LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avenrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXP_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;CALC_LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avenrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXP_5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;CALC_LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avenrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EXP_15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count_active_tasks()&lt;/code&gt; 함수는 active task 개수를 계산하는데 아래와 같은 코드입니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count_active_tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIXED_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;nr_active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;running&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uninterruptible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;for_each_online_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;running&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr_running&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;uninterruptible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr_uninterruptible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uninterruptible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;uninterruptible&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;running&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uninterruptible&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nr_active()&lt;/code&gt;는 nr_running(TASK_RUNNING), nr_uninterruptible(TASK_UNINTERRUPTIBLE)인 프로세스의 개수를 더해서 리턴합니다. 즉, 실행 중인 프로세스와 대기 상태인 프로세스 개수를 계산합니다.&lt;br /&gt;
따라서 지정된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tick&lt;/code&gt; 단위마다, active task(RUNNING, UNINTERRUPTIBLE)를 계산하여 저장하고 이를 이용하여 load average를 계산한다는 것을 알 수 있습니다.&lt;br /&gt;
이 부분에 대한 이해가 깊지는 않지만, 스레드에 대한 고려는 없는 것으로 보입니다. 따라서 chatGPT가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실행 중인 스레드의 개수도 더해야한다&lt;/code&gt;고 설명한 부분은 틀린 답변이 아닌가 싶습니다.&lt;br /&gt;
참고로 load average를 보여주는 함수는 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// fs/proc/loadavg.c&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadavg_proc_show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seq_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;get_avenrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FIXED_1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;seq_printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%lu.%02lu %lu.%02lu %lu.%02lu %ld/%d %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;LOAD_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_FRAC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;LOAD_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_FRAC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;LOAD_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOAD_FRAC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;avnrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nr_running&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nr_threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;task_active_pid_ns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last_pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 함수는 5개 값, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1분,5분,15분 로드평균 (실행 중인 task개수)/(전체 task 개수) (최근 실행된 task의 PID)&lt;/code&gt;를 보여줍니다.&lt;/p&gt;

&lt;p&gt;그렇다면 실제로 보여지는 load average값은 어떻게 계산되는 걸까? tick마다 계산한 모든 값을 저장하고 있다가 평균을 계산할 수도 있겠지만 이런 방법은 너무 많은 자원을 소모합니다. 예를 들어 1초마다 load를 저장하는 경우 1분, 5분, 15분은 각각 60개, 150개, 900개의 값을 저장해야합니다. 따라서, 이전 load average값만을 이용하여 간단하게 계산하는 방법을 도입했고 리눅스는 EMA(Exponential Moving Average)를 사용합니다.&lt;/p&gt;

\[load(t)=load(t-1)e^{\frac{-5}{60m}}+n(t)(1-e^{\frac{-5}{60m}})\]

&lt;ul&gt;
  &lt;li&gt;\(m\): 리포팅을 위한 시간 (1분, 5분, 15분 등)&lt;/li&gt;
  &lt;li&gt;\(load(t)\): 현재의 Load 값&lt;/li&gt;
  &lt;li&gt;\(load(t-1)\): 지난 Load 값&lt;/li&gt;
  &lt;li&gt;\(n(t)\): 현재의 Active Task 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 \(e^{-5/60m}\)가 EMA의 가중치 역할(\(\alpha\))을 합니다.
위와 같은 수식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sched.h&lt;/code&gt; 헤더파일에서 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * These are the constant used to fake the fixed-point load-average
 * counting. Some notes:
 *  - 11 bit fractions expand to 22 bits by the multiplies: this gives
 *    a load-average precision of 10 bits integer + 11 bits fractional
 *  - if you want to count load-averages more often, you need more
 *    precision, or rounding will get you. With 2-second counting freq,
 *    the EXP_n values would be 1981, 2034 and 2043 if still using only
 *    11 bit fractions.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;avenrun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;         &lt;span class=&quot;cm&quot;&gt;/* Load averages */&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define FSHIFT          11              &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* nr of bits of precision */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#define FIXED_1         (1&amp;lt;&amp;lt;FSHIFT)     &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 1.0 as fixed-point */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#define LOAD_FREQ       (5*HZ+1)        &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 5 sec intervals */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#define EXP_1           1884            &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 1/exp(5sec/1min) as fixed-point */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#define EXP_5           2014            &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 1/exp(5sec/5min) */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#define EXP_15          2037            &lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* 1/exp(5sec/15min) */&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define CALC_LOAD(load,exp,n) \
        load *= exp; \
        load += n*(FIXED_1-exp); \
        load &amp;gt;&amp;gt;= FSHIFT;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;load average를 EMA로 계산하기 위해 고정소수점(fixed-point)을 이용하고 있으며, 10 bit는 정수, 11bit는 소수에 할당됩니다.&lt;br /&gt;
1분 load average를 계산하는 경우에, \(e^{-5/60}\)은 부동소수점으로 표현시 약 \(1884\)의 값을 갖습니다.&lt;/p&gt;

\[e^{\frac{-5}{60m}}=0.942...\\
0.942 \times 2^{11} = 1884.250...\]

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXP_1, EXP_5, EXP_15&lt;/code&gt;는 부동소수점 계산을 위해 미리 계산해놓은 고정소수점으로 계산된 근사값이며, 이를 이용하여 load average를 계산하고 있습니다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALC_LOAD&lt;/code&gt; 매크로의 마지막 라인에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FSHIFT&lt;/code&gt;(소수부 bit 수)만큼 shift right해주는 이유는 곱셉 결과 소수부가 22 bit로 확장되었기 때문에 이 결과 중에 11 bit만큼만을 소수부로 사용하기 위해서입니다.
따라서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALC_LOAD&lt;/code&gt;에서 구현한 식은 \(load(t)\)를 계산하는 수식과 동일한 수식임을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;마무리&quot;&gt;마무리&lt;/h3&gt;

&lt;p&gt;프로세스들의 CPU 사용량이 높아지면 load average도 증가합니다. 즉, active task의 개수가 많아지는 경우 load average도 증가합니다. 한편, I/O(Disk I/O, Network I/O) 작업이 많아지는 경우에도 load average가 증가할 수 있습니다. 제가 받았던 알람의 경우에 CPU 사용률은 치솟지 않고 load average만 상승했기 때문에 I/O 쪽의 문제가 아닌지 추측하고 있습니다(정확한 원인 파악은 하지 못했습니다).&lt;/p&gt;

&lt;p&gt;chatGPT 덕분에 구글링으로 몇 시간, 혹은 며칠을 고생했을 의문점을 1~2시간 정도만 투자하고 대강의 내용을 파악하고 제가 궁금한 부분을 더 깊게 파볼 수 있었습니다. 글에는 chatGPT에게 load average에 대해서 물어본 부분만 캡쳐하여 올렸지만, 고정소수점의 연산에 대한 이해에서도 chatGPT의 도움을 받았습니다.&lt;br /&gt;
앞으로도 CS 부분에서 모르는 부분은 chatGPT를 이용하여 적극적으로 검색하고 기록해나가야겠습니다!&lt;/p&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://lunatine.net/2016/02/19/about-load-average/&quot;&gt;Load Average에 대하여&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://bab2min.tistory.com/183&quot;&gt;고정소수점 구현해보기 1. 사칙연산&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="linux" />
      

      
        <summary type="html">chatGPT로 load average로 파헤쳐보기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">WITH절/VIEW 사용 시 쿼리 플랜에 대해서</title>
      <link href="https://gyuhoonk.github.io/impala-with-clause" rel="alternate" type="text/html" title="WITH절/VIEW 사용 시 쿼리 플랜에 대해서" />
      <published>2023-02-16T22:30:00+09:00</published>
      <updated>2023-02-16T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/impala-with-clause</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/impala-with-clause">&lt;p&gt;WITH절/VIEW 사용은 효율적인 쿼리플랜과 관련이 없다&lt;/p&gt;

&lt;h3 id=&quot;with절cte&quot;&gt;WITH절(CTE)&lt;/h3&gt;
&lt;p&gt;WITH절은 SELECT문을 전에 작성하여 복잡한 쿼리를 alias로 처리할 수 있도록 도와줍니다. SELECT문 내에서 여러번 반복해서 사용해야하는 구문을 미리 WITH절로 정의해놓음으로써 작성되는 쿼리의 복잡성을 낮출 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CREATE VIEW&lt;/code&gt;와 비슷하지만, WITH절 내에서 정의된 컬럼명과 테이블은 쿼리 세션이 종료되면 유지되지 않는다는 차이점이 있습니다. 또한, WITH절은 존재하는 테이블/뷰의 이름과 중복되더라도 충돌이 발생하지 않습니다.&lt;/p&gt;

&lt;p&gt;WITH절을 사용하는 목적은 3가지로 요약할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;작성하는 쿼리 내부의 중복을 줄임으로써 쿼리 작성이 편리해집니다.&lt;/li&gt;
  &lt;li&gt;쿼리의 복잡한 부분을 추출하여 WITH절로 정의해둠으로써 쿼리를 읽고 이해하기 쉽게 합니다.&lt;/li&gt;
  &lt;li&gt;WITH절을 지원함으로써 다른 DB와의 호환성이 보장됩니다. 특히, Oracle과의 호환성이 지원됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다만, Impala의 WITH절은 recursive query를 지원하지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;with절-사용-예시&quot;&gt;WITH절 사용 예시&lt;/h4&gt;
&lt;p&gt;WITH절은 아래처럼 차례대로 정의되는 경우가 일반적입니다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- Define 2 subqueries that can be referenced from the body of a longer query.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tab&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;all&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;서브쿼리 내부에서 WITH절을 정의하고 사용할 수도 있습니다. 아래의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t2&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNION ALL&lt;/code&gt;의 앞부분에서 정의되고 사용되었습니다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- Define one subquery at the outer level, and another at the inner level as part of the&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- initial stage of the UNION ALL query.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- UNINON ALL의 앞부분 사적&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;-- UNINON ALL의 앞부분 종료&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;all&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;view1&quot;&gt;VIEW1&lt;/h4&gt;
&lt;p&gt;view는 alias문처럼 동작하는 경량 논리구조(lightweight logical constructs)입니다. SELECT문에서 테이블 이름을 특정해야하는 부분에 view 이름을 적음으로써 사용할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a view is purely a logical construct (an alias for a query) with no physical data behind it&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주의해야할 점은 view는 순수하게 &lt;strong&gt;논리구조&lt;/strong&gt;이므로 실제로 데이터를 따로 저장해두지 않습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALTER VIEW&lt;/code&gt;와 같은 DDL도 view를 관리하는 메타데이터를 변경할 뿐, HDFS에 저장된 데이터 파일에 영향을 주지 않습니다.&lt;/p&gt;

&lt;p&gt;view는 아래와 같은 특징들을 갖습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;압축되고 간단한 문법으로 복잡한 쿼리를 다룰 수 있습니다.&lt;/li&gt;
  &lt;li&gt;복잡한 쿼리의 중복 사용을 줄임으로써, 유지보수를 쉽게 합니다.&lt;/li&gt;
  &lt;li&gt;view 생성 시에 새로운 절, SELECT-LIST, 함수 호출 등을 사용하여 정교한 쿼리를 작성할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;칼럼과 테이블의 이름을 직관적인 이름으로 부여할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;view에 연결된 테이블을 변경하는 과정에서 downtime이 발생하지 않습니다.&lt;/li&gt;
  &lt;li&gt;여러 쿼리들에서 반복적으로 사용되는 같은 서브쿼리를 view로 정의해둠으로써 긴 서브쿼리 작성을 피할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;view를 사용할 때는 아래와 같은 제한사항이 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;impala view에는 데이터를 INSERT할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;view를 생성할 때 사용된 쿼리의 WHERE절과 현재 실행한 쿼리의 WHERE절이 partition pruning에 적용됩니다. 1.4 버전 이전에는 view 생성 시 사용된 쿼리의 WHWERE절만 partition pruning이 적용되었습니다.&lt;/li&gt;
  &lt;li&gt;view 생성 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIMIT&lt;/code&gt;이 없이 사용된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ORDER BY&lt;/code&gt;는 무시됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;with절view-사용과-쿼리-플랜에-대해서&quot;&gt;WITH절/VIEW 사용과 쿼리 플랜에 대해서&lt;/h3&gt;
&lt;p&gt;아래와 같은 쿼리를 작성했을 때, 어떤 query plan이 생성되리라 기대하시나요?&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;WITH&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1_col1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;level1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1_col2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;level1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1_col1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1_col2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;저는 위와 같은 쿼리를 작성하면서 WITH절 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1_col1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1_col2&lt;/code&gt;에서 공통으로 사용하고 있으므로, 아래와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;으로부터 파생되는 WITH절을 생성하는 쿼리 플랜을 기대했었습니다. 즉 전체 쿼리 실행 중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt;로 발생하는 계산은 1회만 발생하리라 예상했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/built/images/hadoop/with-query-plan-1.png&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러나 impala에서 위와 같은 쿼리를 실행했을 때 확인되는 쿼리 플랜은 실제로는 아래와 같았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/built/images/hadoop/with-query-plan-2.png&quot; alt=&quot;image2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실행 중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;table1&lt;/code&gt;은 2번 스캔하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;을 생성하는 WITH절도 2번 실행됩니다. 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GROUP BY&lt;/code&gt; 연산이 2회 발생했습니다. 예상했던 것보다 2배의 스캔량과 2배의 연산이 발생했습니다.&lt;/p&gt;

&lt;p&gt;쿼리를 작성하는 사람은 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1&lt;/code&gt;으로부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1_col1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t1_col2&lt;/code&gt;를 생성하겠다는 의미를 담아 쿼리를 작성했을 확률이 높습니다. 실제로 저 또한 그러했습니다. 그러나 실제로 실행될 때에는 쿼리 작성자의 의도와는 다르게 2번의 스캔과 2번의 연산이 발생하게 됩니다. 이런 차이점이 발생하는 이유는 무엇일까요?&lt;/p&gt;

&lt;p&gt;그것은 기본적으로 WITH절이 VIEW와 같이 &lt;strong&gt;순수한 논리구조(purely a logical construct)&lt;/strong&gt;에 불과하기 때문입니다. 앞서 설명드린 것처럼 VIEW는 실제로 HDFS에 어떤 데이터를 생성하거나 변경시키지 못합니다. 단지 해당 VIEW를 조회할 때, VIEW 생성 시 사용된 로직(SELECT문)을 실행시켜주는 논리구조에 불과합니다.&lt;/p&gt;

&lt;p&gt;WITH절도 VIEW와 마찬가지로 HDFS 어딘가에 그 생성 결과를 저장해두거나 실제 데이터를 변경시키는 작업을 하지 못합니다. 단지 해당 쿼리 세션 내에서 일치하는 부분을 WITH절로 변경시켜주는 것에 불과합니다.&lt;br /&gt;
즉 제가 예시로 들었던 쿼리는 기본적으로 아래의 쿼리를 실행하는 것과 동일하며, 쿼리 플랜 역시 아래 쿼리를 실행하는 것과 동일할 뿐입니다.&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;level1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;level1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col3&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;col2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;같은 예시를 WITH절 대신 VIEW를 사용하여도 같은 결과를 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;따라서 쿼리 작성 시 WITH절/VIEW를 사용함으로써 효율적인 쿼리 플랜을 만들 수 있다고 생각해선 안됩니다. WITH절과 VIEW의 사용은 단순히 1) 쿼리 내 중복 사용을 줄이고, 2) 쿼리를 읽고 이해하기 쉽게 만드는 것임을 기억해야합니다.&lt;/p&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://impala.apache.org/docs/build/plain-html/topics/impala_with.html&quot;&gt;WITH Clause&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://impala.apache.org/docs/build/html/topics/impala_views.html&quot;&gt;Overview of Impala Views&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://impala.apache.org/docs/build/html/topics/impala_create_view.html#create_view&quot;&gt;CREATE VIEW Statement&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="hadoop" />
      

      
        <summary type="html">WITH절/VIEW 사용은 효율적인 쿼리플랜과 관련이 없다</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pod와 Container</title>
      <link href="https://gyuhoonk.github.io/pod-container" rel="alternate" type="text/html" title="Pod와 Container" />
      <published>2023-02-12T22:30:00+09:00</published>
      <updated>2023-02-12T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/pod-container</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/pod-container">&lt;p&gt;Container와 Pod의 기본개념을 확인해봅니다.&lt;/p&gt;

&lt;h2 id=&quot;container란-무엇인가&quot;&gt;Container란 무엇인가?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;컨테이너는 소프트웨어 서비스를 실행하는 데 필요한 특정 버전의 프로그래밍 언어 런타임 및 라이브러리와 같은 종속 항목과 애플리케이션 코드를 함께 포함하는 경량 패키지입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;컨테이너는 운영체제 수준에서 CPU, 메모리, 스토리지, 네트워크 리소스를 쉽게 공유할 수 있게 해주며 컨테이너가 실제로 실행되는 환경에서 애플리케이션을 추상화할 수 있는 논리 패키징 메커니즘을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;구글 클라우드는 컨테이너에 대해 위와 같이 설명합니다. 짧은 두 문장이지만, 컨테이너는 결국 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경량 패지키&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리 패키징 메커니즘&lt;/code&gt;라는 것 같습니다. 구체적으로 어떤 뜻일까요? 컨테이너를 활용하게되면, 개발자는 제공되는 컨테이너에서 애플리케이션을 개발하고, 배포합니다. 컨테이너에는 개발자에게 프로그래밍 언어, 런타임, 라이브러리와 같은 개발 환경이 이미 셋팅(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경량 패키지&lt;/code&gt;)되어있습니다. 따라서 개발자는 이러한 개발 환경 셋팅과 디버깅 과정을 생략하고 애플리케이션 자체에 집중할 수 있습니다. 따라서 컨테이너에 대한 위 설명은 ‘개발과 배포를 하기 위해 필요한 모든 것을 준비해 놓았다!’ 정도로 이해할 수 있을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;conatiner가-개발자에게-주는-장점&quot;&gt;Conatiner가 개발자에게 주는 장점&lt;/h3&gt;
&lt;p&gt;대부분의 개발 프로세스가 오픈 소스 기반으로 이루어지고 있는 지금의 개발 환경에서, 이러한 컨테이너 기반의 개발은 매우 혁명적이었습니다. 컨테이너 기반의 개발 작업이 오픈 소스 기반 개발의 단점을 보완해줄 수 있었기 때문입니다.&lt;/p&gt;

&lt;p&gt;오픈 소스를 기반으로 하는 애플리케이션 개발은 개발자가 직접 작성해야하는 코드의 양을 줄여 개발 생산성을 늘려주었습니다. 덕분에 개발자는 단기간에 높은 수준의 애플리케이션을 만들어낼 수 있었습니다. 그러나 오픈 소스를 기반 개발은 &lt;strong&gt;버전 관리&lt;/strong&gt;라는 맹점이 존재합니다. 사용하는 오픈 소스 라이브러리의 버전업이 개발한 애플리케이션에 어떤 영향을 줄 지 예상이 불가능했고, 이는 다양한 버그와 호환성 문제를 야기했습니다. 즉 개발 생산성을 높이는 대신 애플리케이션의 안정성이 떨어지는 트레이드 오프가 발생했습니다.&lt;/p&gt;

&lt;p&gt;컨테이너는 오픈소스 기반 애플리케이션 개발의 불안정성을 보완해주었습니다. 같은 컨테이너 내에서는 제공되는 언어, 런타임, 라이브러리, 종속 항목들이 고정되어 있으므로 애플리케이션 빌드나 배포 시에 오픈 소스 라이브러리의 버전업이나 수정, 패치에 영향받지 않습니다.&lt;/p&gt;

&lt;p&gt;또한 컨테이너가 제공되고, 실행만 가능하다면 개인 노트북을 포함한 어떤 환경에서도 동일한 개발환경을 유지한 채 개발작업을 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이외에도 컨테이너는 개발자와 인프라 운영팀의 책임을 분명히 구분해주는 책임 분리(Separation of responsibility), 실해되는 다른 애플리케이션으로부터 영향을 받지 않는 애플리케이션 격리라는 장점을 갖습니다.&lt;/p&gt;

&lt;h2 id=&quot;pod란-무엇인가&quot;&gt;Pod란 무엇인가?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;파드(Pod) 는 쿠버네티스에서 생성하고 관리할 수 있는 배포 가능한 가장 작은 컴퓨팅 단위이다.&lt;br /&gt;
파드 (고래 떼(pod of whales)나 콩꼬투리(pea pod)와 마찬가지로)는 하나 이상의 컨테이너의 그룹이다. 이 그룹은 스토리지 및 네트워크를 공유하고, 해당 컨테이너를 구동하는 방식에 대한 명세를 갖는다. 파드의 콘텐츠는 항상 함께 배치되고, 함께 스케줄되며, 공유 콘텍스트에서 실행된다. 파드는 애플리케이션 별 “논리 호스트”를 모델링한다. 여기에는 상대적으로 밀접하게 결합된 하나 이상의 애플리케이션 컨테이너가 포함된다. 클라우드가 아닌 콘텍스트에서, 동일한 물리 또는 가상 머신에서 실행되는 애플리케이션은 동일한 논리 호스트에서 실행되는 클라우드 애플리케이션과 비슷하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;애플리케이션 컨테이너와 마찬가지로, 파드에는 파드 시작 중에 실행되는 초기화 컨테이너가 포함될 수 있다. 클러스터가 제공하는 경우, 디버깅을 위해 임시 컨테이너를 삽입할 수도 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Kubernetes 공식문서에서는 Pod를 위와 같이 설명합니다. 요약해보자면, Pod를 아래와 같은 특징으로 요약될 수 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;파드는 쿠버네티스에서 생성/관리 가능한 가장 작은 컴퓨팅 단위이다&lt;/li&gt;
  &lt;li&gt;파드의 콘텐츠는 함께 배치, 스케줄, (공유 콘텍스트에서)실행된다&lt;/li&gt;
  &lt;li&gt;파드는 애플리케이션 별로 논리 호스트를 모델링한다&lt;/li&gt;
  &lt;li&gt;파드에는 초기화 컨테이너, 임시 컨테이너를 삽입할 수 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;각 항목에 대해서 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;가장-작은-컴퓨팅-단위&quot;&gt;가장 작은 컴퓨팅 단위&lt;/h3&gt;
&lt;p&gt;실제로 애플리케이션이 실행되는 것은 파드 내에 존재하는 컨테이너(Container)이지만, 쿠버네티스는 직접 컨테이너를 실행하지 않고, 파드를 실행합니다. 쿠버네티스에 의해 실행된 파드가 파드 내의 컨테이너를 관리합니다. 즉, 쿠버네티스 자체는 컨테이너에 직접적으로 관여하지 않습니다. 대신 컨트롤러(controller)를 이용하여 파드를 관리합니다.&lt;br /&gt;
한편, 파드는 LivenessProbe, ReadienessProbe를 설정하여 파드 내부의 컨테이너에서 실행되는 애플리케이션의 상태를 모니터링합니다.&lt;/p&gt;

&lt;h3 id=&quot;파드의-콘텐츠는-배치-스케줄-콘텍스트를-공유&quot;&gt;파드의 콘텐츠는 배치, 스케줄, 콘텍스트를 공유&lt;/h3&gt;
&lt;p&gt;동일 파드 내에서 실행되는 컨테이너들은 모두 같은 노드에서 실행되며, 동일 파드에 의해 관리되는 여러 컨테이너들은 동일한 리소스 및 로컬 네트워크를 공유합니다. 따라서 파드 내 컨테이너들은 분리되어 실행되더라도 통신과 리소스 공유가 가능합니다. 공유 컨텍스트(shared context)란 동일 파드 내 컨테이너 간에는 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 통신이 가능하고, 볼륨 마운트(Volume Mount)를 통하여 파일 시스템을 공유할 수 있음을 의미하는 것으로 보입니다.&lt;/p&gt;

&lt;h3 id=&quot;애플리케이션-별로-논리-호스트를-모델링&quot;&gt;애플리케이션 별로 논리 호스트를 모델링&lt;/h3&gt;
&lt;p&gt;추상적인 단어가 많아 이해하기가 어려운 개념이었습니다. 일단 원문을 다시 읽어보았습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A Pod models an application-specific “logical host”: it contains one or more application containers which are relatively tightly coupled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쿠버네티스 문서에서 제공하는 번역이 원문의 의미를 전달하지 못하고 있는 것 같습니다. 몇 가지 단어를 중심으로 의미를 풀어보고자 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aplication-specific&lt;/code&gt;이란 특정 어플리케이션을 위해서 작성되었다는 의미입니다(&lt;a href=&quot;https://en.wiktionary.org/wiki/application-specific&quot;&gt;application-specific&lt;/a&gt;). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;애플리케이션 별로&lt;/code&gt;로 번역되어 그 의미가 정확히 전달되지 못한 것 같습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리 호스트&lt;/code&gt;로 번역된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logical host&lt;/code&gt;는 어플리케이션을 실행을 위해 필요로 하는 소프트웨어와 컴포넌트를 갖추고 있는 환경 자체를 의미합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 두 가지 의미를 합쳐보면, Pod는 어플리케이션을 위해 작성된, 어플리케이션을 실행할 수 있는 환경 그 자체라고 해석할 수 있습니다. 나아가, Pod는 한 가지 어플리케이션만 실행하는 것이 아니라, 서로 관련 있는 여러 개의 어플리케이션을 포함할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;초기화-컨테이너-임시-컨테이너&quot;&gt;초기화 컨테이너, 임시 컨테이너&lt;/h3&gt;
&lt;p&gt;Pod에는 초기화만을 담당하는 컨테이너를 설정할 수 있습니다. 이를 초기화 컨테이너(initContainer)라고 부르며 해당 컨테이너는 Pod 시작 후에 가장 먼저 시작되어 초기화 작업을 수행하고 이후 메인 컨테이너들이 실행됩니다. 이외에도 디버깅을 위해 임시 컨테이너(Ephemeral Container)를 설정할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;위의 4가지 특징 이외에도 Pod는 아래 특징을 가지고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;pod는-일시적인-존재&quot;&gt;Pod는 일시적인 존재&lt;/h3&gt;
&lt;p&gt;Pod는 일시적인 존재로 설계되어 Pod 내의 컨테이너는 이미지로부터 매번 생성되빈다. 따라서 같은 오브젝트 이름으로 재기동하여도, 이전 컨테이너의 실행기록(로그), 변경 사항은 남지 않고 초기 이미지 상태에서부터 재실행됩니다.&lt;br /&gt;
또한 Pod의 IP도 고정적이지 않습니다. Pod의 IP는 생성과 함께 부여된 뒤, 종료 시에 회수됩니다. 재시작하더라도 같은 IP를 부여하지 않습니다. 따라서 Pod에게 요청(request)를 보내고자 하는 경우에는 반드시 service를 이용하여 고정 IP를 제공해야합니다.&lt;/p&gt;

&lt;h2 id=&quot;controller&quot;&gt;Controller&lt;/h2&gt;
&lt;p&gt;이러한 Pod는 워크로드 리소스(컨트롤러)에 의해 생성되고 관리됩니다. 컨트롤러는 파드 장애 시 복제 및 롤아웃과 자동복구를 처리합니다. 어떤 노드에서 장애가 발생했을 때, 컨트롤러는 장애 노드에서 실행되는 Pod들의 작동 중지를 인식하고, 다른 노드에서 대체 Pod를 생성하는 식으로 대응합니다. 이러한 컨트롤러에는 7가지가 있습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Deployment 디플로이먼트&lt;/li&gt;
  &lt;li&gt;ReplicaSet 레플리카셋&lt;/li&gt;
  &lt;li&gt;StatefultSet 스테이트풀셋&lt;/li&gt;
  &lt;li&gt;DaemonSet 데몬셋&lt;/li&gt;
  &lt;li&gt;Job 잡&lt;/li&gt;
  &lt;li&gt;CronJob 크론잡&lt;/li&gt;
  &lt;li&gt;ReplicationController 레플리케이션 컨트롤러&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Deployment의 템플릿 예시는 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# 여기서부터 파드 템플릿이다&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:1.14.2&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;# 여기까지 파드 템플릿이다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단하게 컨테이너와 파드의 개념에 대해 정리해보았고, 파드를 관리하는 컨트롤러가 무엇이 있는지까지만 알아보았습니다.&lt;br /&gt;
읽어주셔서 감사합니다 (_ _)&lt;/p&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/learn/what-are-containers?hl=ko&quot;&gt;GCP 컨테이너란?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/ko/docs/concepts/workloads/pods/&quot;&gt;Kubernetes 파드&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.redhat.com/ko/topics/containers/what-is-kubernetes-pod&quot;&gt;RedHat 쿠버네티스 포드(Kubernetes pod)란?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.yes24.com/Product/Goods/93317828&quot;&gt;15단계로 배우는 도커와 쿠버네티스&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="kubernetes" />
      

      
        <summary type="html">Container와 Pod의 기본개념을 확인해봅니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Oracle DB Connection String</title>
      <link href="https://gyuhoonk.github.io/oracle-connection" rel="alternate" type="text/html" title="Oracle DB Connection String" />
      <published>2022-12-24T22:30:00+09:00</published>
      <updated>2022-12-24T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/oracle-connection</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/oracle-connection">&lt;p&gt;oracle database connection String 설정에 대해 알아봅니다.&lt;/p&gt;

&lt;h1 id=&quot;jdbc-driver&quot;&gt;JDBC Driver&lt;/h1&gt;
&lt;p&gt;JDBC 드라이버는 Java App이 데이터베이스와 상호작용(데이터를 가져오거나 저장)하는 것을 가능하게 합니다. JDBC 클래스는  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.sql&lt;/code&gt; 패키지에 포함되어 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javax.sql.JDBC&lt;/code&gt;는 아래와 같은 역할을 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스와 같은 데이터 소스와의 연결&lt;/li&gt;
  &lt;li&gt;쿼리를 전송&lt;/li&gt;
  &lt;li&gt;작성한 쿼리에 대한 응답(데이터)을 처리하고 반환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JDK와 함께 제공되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.sql&lt;/code&gt; 패키지에는 기능을 구현하고 있는 여러 클래스를 포함하고 있으며, 서드 파티 드라이버를 이용하여 실제로 구현할 수 있습니다. 서드 파티 공급자(vendor)는 그들의 데이터베이스 드라이버에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;java.sql.Driver&lt;/code&gt; 인터페이스를 구현해야합니다. 이러한 JDBC 드라이버는 사용되는 기술과 연결되는 데이터베이스에 따라 4가지 타입으로 구분됩니다.&lt;/p&gt;
&lt;h2 id=&quot;type-1-bridge-driver&quot;&gt;Type-1: Bridge Driver&lt;/h2&gt;
&lt;p&gt;Type-1 Driver JDBC는 브릿지 드라이버(bridge driver)라고도 불립니다. Type-1은 각각의 클라이언트에 설치된 ODBC 드라이버에 접근할 수 있는 다리(bridge)를 제공합니다. Type-1은 JDBC 메소드 호출(calls to JDBC methods)를 ODBC 함수 호출(calls to ODBC functions)로 치환합니다. 브릿지 드라이버는 설치되어있는 ODBC 드라이버에 의해 제공되는 데이터베이스 연결에 JDBC App이 즉각 접근할 수 있도록 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;하나의 드라이버로 다른 데이터 소스에 접근할 수 있습니다.&lt;/li&gt;
      &lt;li&gt;모든 ODBC가 제공되는 데이터베이스에 사용할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;Java APP은 ODBC에만 의존해야합니다.&lt;/li&gt;
      &lt;li&gt;모든 클라이언트는 ODBC를 설치해야합니다.&lt;/li&gt;
      &lt;li&gt;JDBC 메소드 호출을 ODBC 함수 호출로 변환하기 때문에 성능이 하락할 수 있습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;type-2-oracle-call-interfaceoci-driver&quot;&gt;Type-2: Oracle Call Interface(OCI) Driver&lt;/h2&gt;
&lt;p&gt;Oracle client 설치와 함께 클라이언트 측에서 사용됩니다. App과 함께할 때에만 사용될 수 있습니다. 즉, Type-2 드라이버는 Java App과 함께 사용됩니다. Type-2 드라이버는 특정 플랫폼에 맞는 OCI 라이브러리를 요구합니다. InterProcessCommunication(IPC), named pipes, TCP/IP, Internetwork Packet Exchange/Sequenced Packet Exchange(IPX/SPX)를 포함하는 설치된 모든 Oracle Net adapter를 지원합니다.&lt;/p&gt;

&lt;p&gt;Java와 C를 이용하여 작성된 OCI 드라이버는 C-entry 포인트를 호출하는 네이티브 메서드를 이용하여 JDBC  호출을 OCI 호출로 변환합니다. 이러한 호출 과정에서 Oracle Net Service를 이용하여 데이터베이스와 커뮤니케이션합니다.&lt;/p&gt;

&lt;p&gt;OCI 드라이버는 클아이언트 컴퓨터에 설치되어 있는 OCI 라이브러리, C-entry points, Oracle Net, core 라이브러리와 다른 필수적인 파일들을 이용합니다.&lt;br /&gt;
OCI는 3세대 언어의 네이티브 프로시저 또는 함수 호출을 사용하여 Oracle Database에 액세스하고 SQL 문 처리의 모든 단계를 제어하는 응용프로그램을 만들 수 있는 API입니다.&lt;/p&gt;

&lt;h2 id=&quot;type-3-network-protocol-driver&quot;&gt;Type-3: Network Protocol Driver&lt;/h2&gt;
&lt;p&gt;JDBC 호출을 직간접적으로 vendor-specific database protocol로 변환해주는 application server를 이용합니다. Type-3 드라이버는 JDBC 호출을 middleware vendor’s protocol로 변환합니다. 이후에 변환된 프로토콜은 다양한  데이터베이스에 연결을 제공하고 있는 middleware server에 의해 database-specific protocol로 다시 변환됩니다.&lt;/p&gt;

&lt;p&gt;middleware는 OS와 OS에서 실행되는 App 사이에 있는 소프트웨어입니다. 필수적으로 hidden translation layer로서 기능하면서, middleware는 분산 응용프로그램(distributed application)을 위한 데이터 매니지먼트와 커뮤니케이션을 가능케 합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;사용자가 여러 개의 데이터베이스에 연결해야하고, 하나의 드라이버를 사용하고 싶을 경우에 사용됩니다.&lt;/li&gt;
      &lt;li&gt;이미 서버에 설치되어 있으므로 클라이언트 측에 드라이버 코드를 설치할 필요가 없습니다.&lt;/li&gt;
      &lt;li&gt;백엔드 서버 컴포넌트는 데이터베이스가 실행되고 있는 OS에 최적화되어있습니다.&lt;/li&gt;
      &lt;li&gt;Type-1, Type-2에 비해 좋은 성능을 보입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;middleware가 다른 머신에서 실행 중이라면, Type-4가 더 효과적일 수 있습니다.&lt;/li&gt;
      &lt;li&gt;database에 특화된 코드가 middleware 서버에 설치되어 있어야합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;type-4-native-protocol-driver&quot;&gt;Type-4: Native Protocol Driver&lt;/h2&gt;
&lt;p&gt;데이터베이스와 직접적으로 상호작용합니다. native database library를 필요로 하지 않기 때문에 &lt;strong&gt;Thin Driver&lt;/strong&gt;라고도 불립니다. native library는 물론, middleware server도 필요로 하지 않으므로, no-client-side이며 no-server-side로 설치됩니다. 완벽하게 Java로 작성되어 있기 때문에 이동가능한(portable) 드라이버입니다.&lt;/p&gt;

&lt;p&gt;Thin Driver는 JDBC 호출을 직접적으로 vendor-specific database protocol로 변환합니다. 또한, Thin Driver는 플랫폼에 영향을 받지 않습니다(platform-independent). 하지만, native protocol을 사용하기 때문에 데이터베이스에 영향을 받습니다.(Protocol can establish a connection between particular server only)&lt;/p&gt;

&lt;h1 id=&quot;jdbc-name-url&quot;&gt;JDBC Name URL&lt;/h1&gt;
&lt;p&gt;JDBC NAME URL의 템플릿은 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jdbc:oracle:[driver_type]:[username/password]@[database_specifier]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;driver_type&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;database_specifier&lt;/code&gt;에 대해서 설명해보고자 합니다.&lt;/p&gt;

&lt;h2 id=&quot;driver_type&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;driver_type&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;어떤 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;driver_type&lt;/code&gt;을 사용하는지를 결정합니다. 드라이버 타입에 맞는 이름을 작성해주어야합니다.&lt;/p&gt;
&lt;h3 id=&quot;server-side-internal-driver-kprb&quot;&gt;server-side internal driver: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kprb&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;server-side internal driver를 사용하는 경우에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kprb&lt;/code&gt;로 입력해야합니다. 이 경우에 다른 속성은 모두 무시됩니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Connection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DriverManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getConnection&lt;/span&gt; 
                  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbc:oracle:kprb:@&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;jdbc-thin-or-oci-driver-thinoci&quot;&gt;JDBC Thin or OCI Driver: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thin&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;oci&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Thin이나 OCI 드라이버를 사용하는 경우입니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;URL 세팅이 user/password를 포함할 수 있다면, 아래와 같이 작성합니다. 특히, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thin&lt;/code&gt;이 이에 해당합니다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jdbc:oracle:thin:HR/hr@localhost:5221:orcl&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;url property가 존재한다면, tnsEntry, driverType, portNumber, networkProtocol, serverName, databaseName property는 모두 무시됩니다.&lt;/li&gt;
  &lt;li&gt;tnsEntry property가 존재하고, url property가 존재하지 않는다면, databaseName, serverName, portNumber, networkProtocol property는 모두 무시됩니다.&lt;/li&gt;
  &lt;li&gt;OCI 드라이버를 사용하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;networkProtocol&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipc&lt;/code&gt;로 셋팅되어있다면, 다른 셋팅은 모두 무시됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;database_specifier&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;database_specifier&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;database specifier는 어플리케이션이 연결을 필요로하는 특정 데이터베이스를 확인하기 위해 사용됩니다. 일부 데이터베이스는 오직 thin에서만, 혹은 오직 oci 드라이버에서만 작동합니다. thin, oci 모두 사용할 수 있는 데이터베이스(oracle)도 존재합니다.&lt;/p&gt;
&lt;h3 id=&quot;ipv6를-지원한다&quot;&gt;IPv6를 지원한다&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)
    (HOST=[2001:0db8:7654:3210:FEDC:BA98:7654:3210])(PORT=5521))
    (CONNECT_DATA=(SERVICE_NAME=sales.example.com))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위처럼 IPv6로 host를 전달할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;supported-database-specifiers&quot;&gt;Supported Database Specifiers&lt;/h3&gt;
&lt;p&gt;데이터베이스에 따라 database specifier를 사용할 수 있는 드라이버 타입이 다릅니다. 구체적인 내용은 아래 표와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Specifier&lt;/th&gt;
      &lt;th&gt;Supported Drivers&lt;/th&gt;
      &lt;th&gt;Example&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Oracle Net connection descriptor&lt;/td&gt;
      &lt;td&gt;Thin, OCI&lt;/td&gt;
      &lt;td&gt;Thin, using an address list:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url=&quot;jdbc:oracle:thin:@(DESCRIPTION=  (LOAD_BALANCE=on) (ADDRESS_LIST=  (ADDRESS=(PROTOCOL=TCP)(HOST=host1) (PORT=5221)) (ADDRESS=(PROTOCOL=TCP)(HOST=host2)(PORT=5221))) (CONNECT_DATA=(SERVICE_NAME=orcl)))&quot; &lt;/code&gt;OCI, using a cluster:&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;jdbc:oracle:oci:@(DESCRIPTION=  (ADDRESS=(PROTOCOL=TCP)(HOST=cluster_alias)    (PORT=5221))    (CONNECT_DATA=(SERVICE_NAME=orcl)))&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Thin-style service name&lt;/td&gt;
      &lt;td&gt;Thin&lt;/td&gt;
      &lt;td&gt;Refer to &lt;a href=&quot;https://docs.oracle.com/database/121/JJDBC/urls.htm#BEIDHCBA&quot;&gt;“Thin-style Service Name Syntax”&lt;/a&gt; for details.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;jdbc:oracle:thin:HR/hr@//localhost:5221/orcl&quot; &lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LDAP syntax&lt;/td&gt;
      &lt;td&gt;Thin&lt;/td&gt;
      &lt;td&gt;Refer to &lt;a href=&quot;https://docs.oracle.com/database/121/JJDBC/urls.htm#CHDBICFA&quot;&gt;LDAP Syntax&lt;/a&gt; for details.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;jdbc:oracle:thin:@ldap://ldap.example.com:7777/sales,cn=OracleContext,dc=com&quot; &lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bequeath connection&lt;/td&gt;
      &lt;td&gt;OCI&lt;/td&gt;
      &lt;td&gt;Empty. That is, nothing after @&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;jdbc:oracle:oci:HR/hr/@&quot; &lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TNSNames alias&lt;/td&gt;
      &lt;td&gt;Thin, OCI&lt;/td&gt;
      &lt;td&gt;Refer to &lt;a href=&quot;https://docs.oracle.com/database/121/JJDBC/urls.htm#BEIDIJCE&quot;&gt;“TNSNames Alias Syntax”&lt;/a&gt; for details.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OracleDataSource ods = new OracleDataSource(); ods.setTNSEntryName(&quot;MyTNSAlias&quot;);&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;2-node-rac-db-stystem&quot;&gt;2-Node RAC DB Stystem&lt;/h1&gt;
&lt;p&gt;database specifier를 작성할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDRESS_LIST&lt;/code&gt;라는 옵션은 왜 존재하는 것일까요? 위의 예시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADDRESS_LIST&lt;/code&gt;에 2개의 host가 작성되어있음을 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jdbc:oracle:thin:@(DESCRIPTION=  (LOAD_BALANCE=on) 
  (ADDRESS_LIST=  
    (ADDRESS=(PROTOCOL=TCP)(HOST=host1)(PORT=5221)) 
    (ADDRESS=(PROTOCOL=TCP)(HOST=host2)(PORT=5221))) 
  (CONNECT_DATA=(SERVICE_NAME=orcl)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이는 oracle이 2-Node RAC(Real Application Clusters) DB System을 지원하기 때문입니다. 이는 고가용성(High Availability)를 위해 고안된 시스템입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/database/OracleRAC_nodes.jpeg&quot; alt=&quot;2-node-rac-db-system&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 구조를 갖게 되면, 메인으로 연결된 노드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node1&lt;/code&gt;)에 대한 연결이 실패하더라도, 예비 노드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node2&lt;/code&gt;)로 즉각 연결하여 DB 연결이 끊어지는 문제를 방지할 수 있습니다.&lt;br /&gt;
2-Node RAC DB System이 주는 장점은 아래와 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Load balancing&lt;br /&gt;
DB에 요청이 많을 경우 2개 노드에 분산하여 처리할 수 있습니다(로드 밸런싱). 다만 성능 이슈가 발생할 수 있으므로 해당 옵션은 꺼두는 것을 권장합니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOAD_BALANCE=OFF&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;SCAN (Single Client Access Name)&lt;br /&gt;
node에 대해 기술하지 않아도, RAC failover가 가능합니다. 기존에는 initial node와 failover node를 설정해야했지만, JDBC URL를 작성하여 oracle과 연결하면 SCAN이 자동으로 initial/failover를 선택합니다.&lt;/li&gt;
  &lt;li&gt;High availability (Failover)&lt;br /&gt;
최초 연결 시에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FAILOVER=ON&lt;/code&gt; 옵션을 주고 연결하면 timeout 내에 해당 노드와 연결이 되지 않았을 때 다른 노드로 자동으로 연결을 수행합니다.&lt;/li&gt;
  &lt;li&gt;High availability (Failover), continued&lt;br /&gt;
이러한 고가용성은 연결 중에도 작동합니다. 연결된 노드에 장애가 발생하여 connection이 중간에 끊어지면 다른 노드로 자동으로 연결을 수행합니다. 이때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifespan&lt;/code&gt; 옵션을 설정하면 장애가 발생한 노드가 복구되었는지 확인하여 기존 노드로 연결을 수정합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://www.geeksforgeeks.org/jdbc-type-1-driver/?ref=rp&quot;&gt;JDBC – Type 1 Driver
&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.oracle.com/en/database/oracle/oracle-database/21/jjdbc/introducing-JDBC.html#GUID-D6975767-9F5A-4B30-8910-9298DDD7FEF0&quot;&gt;Overview of Oracle JDBC Drivers&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.oracle.com/cd/A97335_02/apps.102/a83724/advanc4.htm&quot;&gt;JDBC in the Server: the Server-Side Internal Driver
&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.oracle.com/database/121/ODPNT/featConnecting.htm#ODPNT164&quot;&gt;oracle-featConnecting&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.oracle.com/database/121/JJDBC/urls.htm#JJDBC28267&quot;&gt;oracle-urls&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.ibm.com/docs/en/b2b-integrator/5.2?topic=odcm-using-oracle-real-application-clusters-rac-high-availability&quot;&gt;Using Oracle Real Application Clusters (RAC) for High Availability&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="database" />
      

      
        <summary type="html">oracle database connection String 설정에 대해 알아봅니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Linux 사용자 관리, 파일속성 그리고, 특수권한</title>
      <link href="https://gyuhoonk.github.io/special-permissions" rel="alternate" type="text/html" title="Linux 사용자 관리, 파일속성 그리고, 특수권한" />
      <published>2022-11-19T22:30:00+09:00</published>
      <updated>2022-11-19T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/special-permissions</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/special-permissions">&lt;p&gt;Linux 사용자 관리, 파일속성 그리고, 특수권한에 대해서 알아봅니다.&lt;/p&gt;

&lt;h1 id=&quot;linux-사용자그룹과-파일-관리&quot;&gt;Linux 사용자,그룹과 파일 관리&lt;/h1&gt;
&lt;p&gt;Linux는 파일 관리를 위해 아래와 같은 개념을 도입했습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;사용자와 그룹(User and Group)&lt;/li&gt;
  &lt;li&gt;파일 허가권(Permission)&lt;/li&gt;
  &lt;li&gt;파일 소유권(Ownership)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-사용자와-그룹user-and-group&quot;&gt;1. 사용자와 그룹(User and Group)&lt;/h2&gt;
&lt;p&gt;리눅스가 사용자와 그룹 개념을 도입함으로써, 1대의 리눅스 서버에 여러 명이 동시에 접속해서 사용할 수 있습니다. 
처음에 리눅스를 설치하면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;라는 이름을 가진 super user가 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;는 시스템의 모든 작업을 실행할 수 있는 권한이 있고, 시스템에 접속할 수 있는 사용자를 생성할 수 있는 권한도 있습니다. 
사용자(User)는 혼자서 존재하지 않고 어떤 그룹(Group)에 속해야합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/passwd
nobody:x:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:x:0:0:System Administrator:/var/root:/bin/sh
daemon:x:1:1:System Services:/var/root:/usr/bin/false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위의 각 행의 의미는 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{사용자 이름}:{암호}:{사용자ID}:{사용자가 소속된 그룹}:{추가 정보}:{홈 디렉토리}:{기본 셀}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;암호가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;로 표시된 경우에 해당 암호는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt;에서 확인할 수 있습니다.
이번에는 그룹(Group)을 확인해봅니다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/group
nobody:x:-2:
nogroup:x:-1:
wheel:x:0:root
daemon:x:1:root
kmem:x:2:root
sys:x:3:root
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;각 행의 의미는 아래와 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{그룹 이름}:{비밀번호}:{그룹 ID}:{보조 그룹 사용자}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보조 그룹 사용자&lt;/code&gt;란 이 그룹을 주 그룹(main group)이 아닌 보조 그룹(sub group)으로 사용하는 사용자의 목록이 추가됩니다. 여러명이 있는 경우에는 컴마로 구분됩니다.&lt;/p&gt;

&lt;h2 id=&quot;2-파일-허가권permission과-소유권ownership&quot;&gt;2. 파일 허가권(Permission)과 소유권(Ownership)&lt;/h2&gt;
&lt;p&gt;리눅스는 각각의 파일과 디렉터리마다 소유권과 허가권을 갖습니다. 아래와 같이 확인이 가능합니다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 root root 0 7월 15 16:11 sample.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;표시된 정보는 아래 표와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;-&lt;/th&gt;
      &lt;th&gt;rx-r–r–&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;root&lt;/th&gt;
      &lt;th&gt;root&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;7월 15 16:11&lt;/th&gt;
      &lt;th&gt;sample.txt&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;파일 유형&lt;/td&gt;
      &lt;td&gt;파일 허가권&lt;/td&gt;
      &lt;td&gt;링크 수&lt;/td&gt;
      &lt;td&gt;파일 소유자&lt;/td&gt;
      &lt;td&gt;파일 소유그룹&lt;/td&gt;
      &lt;td&gt;파일 크기(byte)&lt;/td&gt;
      &lt;td&gt;마지막 변경 날짜/시간&lt;/td&gt;
      &lt;td&gt;파일 이름&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;각 항목에 대해서 간략하게 정리해보겠습니다.&lt;/p&gt;
&lt;h3 id=&quot;파일-유형&quot;&gt;파일 유형&lt;/h3&gt;
&lt;p&gt;어떤 종류의 파일인지를 나타내며 아래와 같은 종류가 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;표시&lt;/th&gt;
      &lt;th&gt;파일 유형&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;일반 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;블록 디바이스(Block Device)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;문자 디바이스(Character Device)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;링크(Link)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;(블록 디바이스)는 하드디스크, 플로피디스크, CD/DVD 등의 저장장치를 말합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt;(문자 디바이스)는 마우스, 키보드, 프린터 등의 입출력장치에 해당합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l&lt;/code&gt;(링크)는 ‘바로 가기 아이콘’처럼 연결되어있는 파일을 의미합니다(실제 파일은 다른 곳에 존재합니다).&lt;/p&gt;

&lt;h3 id=&quot;파일-허가권permission&quot;&gt;파일 허가권(Permission)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rw-&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r--&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r--&lt;/code&gt; 로 3개씩 끊어서 인식해야합니다. 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rwx&lt;/code&gt;의 의미는 아래와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;허가권&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;READ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;WRITE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;EXECUTE&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3개씩 끊었을 때 앞에서부터의 갖는 의미는 아래와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;블록&lt;/th&gt;
      &lt;th&gt;대상&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rw-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;소유자(user)&lt;/td&gt;
      &lt;td&gt;소유자는 읽거나 쓸 수 있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r--&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;그룹(group)&lt;/td&gt;
      &lt;td&gt;그룹은 읽을 수만 있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r--&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;그외 사용자(other)&lt;/td&gt;
      &lt;td&gt;그 외 사용자는 읽을 수만 있다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;허가권은 아래와 같이 숫자로도 표현될 수 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;User&lt;/th&gt;
      &lt;th&gt;User&lt;/th&gt;
      &lt;th&gt;User&lt;/th&gt;
      &lt;th&gt;Group&lt;/th&gt;
      &lt;th&gt;Group&lt;/th&gt;
      &lt;th&gt;Group&lt;/th&gt;
      &lt;th&gt;Other&lt;/th&gt;
      &lt;th&gt;Other&lt;/th&gt;
      &lt;th&gt;Other&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2진법&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10진법&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;합(10진법)&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rwx&lt;/code&gt;를 2진법 3자리수에 대응하여 위와 같이 풀이하는 것도 가능합니다. 따라서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rw-r--r--&lt;/code&gt;라고 길게 쓴 파일허가권에 대한 설명은 2진법으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;110100100&lt;/code&gt;이고, 이를 3자리씩 끊어서 10진법으로 변환하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;644&lt;/code&gt;에 해당합니다.
반대로 파일 허가권이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;754&lt;/code&gt;인 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111101100&lt;/code&gt;이고, 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rwxr-xr--&lt;/code&gt;로 풀이됩니다. 이 경우 의미는 소유자는 읽기/쓰기/실행이 가능하고, 그룹은 읽기/실행이 가능, other는 읽기만 가능입니다.
참고로, 디렉터리로 이동(진입)하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;(실행) 권한이 반드시 필요합니다. 따라서 일반적으로 소유자/그룹/other 모두에게 실행 권한이 설정되어 있습니다.&lt;/p&gt;

&lt;p&gt;파일의 허가권을 변경하고 싶은 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chmod&lt;/code&gt; 명령어를 실행해야합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 혹은 소유자만이 해당 파일의 허가권을 변경할 수 있습니다. 아래와 같이 사용합니다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;777 sample.txt
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;u+x sample.txt &lt;span class=&quot;c&quot;&gt;# User의 권한에 실행 권한을 추가&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;u-wx sample.txt &lt;span class=&quot;c&quot;&gt;# User의 권한에 쓰기/실행 권한을 제거&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;파일-소유권ownership&quot;&gt;파일 소유권(Ownership)&lt;/h3&gt;
&lt;p&gt;소유권은 파일을 소유한 &lt;strong&gt;사용자&lt;/strong&gt;와 &lt;strong&gt;그룹&lt;/strong&gt;을 의미합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sample.txt&lt;/code&gt;의 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 사용자와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 그룹이 소유하고 있습니다. 소유권은 아래와 같은 명령어로 변경할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chown &lt;/span&gt;ubuntu sample.txt &lt;span class=&quot;c&quot;&gt;# sample.txt의 소유자를 ubuntu로 변경&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chown &lt;/span&gt;ubuntu.ubuntu sample.txt &lt;span class=&quot;c&quot;&gt;# sample.txt의 소유자와 소유 그룹을 ubuntu 그룹으로 변경&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chgrp &lt;/span&gt;ubuntu sample.txt &lt;span class=&quot;c&quot;&gt;# 그룹만 ubuntu로 변경&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;링크link&quot;&gt;링크(Link)&lt;/h3&gt;
&lt;p&gt;링크는 하드 링크(Hard Link)와 심볼릭 링크(Symbolic Link)로 나뉩니다. 먼저, 링크를 이해하기 전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode&lt;/code&gt;에 대해서 알고 있어야합니다.&lt;/p&gt;

&lt;h4 id=&quot;inode&quot;&gt;inode&lt;/h4&gt;
&lt;p&gt;inode는 리눅스/유닉스 파일 시스템에서 사용하는 자료구조로서, 파일이나 디렉터리의 정보를 저장하고 있습니다. 모든 파일/디렉터리는 각각 1개씩의 inode를 갖고 있으며 inode 내에 파일의 소유권, 허가권, 파일 종류 등의 정보와 해당 파일의 실제 위치(address)가 저장되어 있습니다. inode가 저장되어 있는 공간을 inode block이라고 하며 일반적으로 전체 디스크 공간의 1%가 inode block으로 사용됩니다. 반대로, Data Block은 실제로 데이터가 저장되어 있는 공간으로 나머지 99%를 사용합니다.&lt;/p&gt;

&lt;p&gt;링크 생성 시 링크 대상이 되는 파일의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode&lt;/code&gt;를 공유하느냐, 새로운  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode&lt;/code&gt;를 생성하느냐에 따라 하드 링크와 심볼릭 링크로 나뉩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/linux/link.webp&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 표현된 것처럼, 하드링크는 대상(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filename&lt;/code&gt;)의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode1&lt;/code&gt;을 공유합니다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filename&lt;/code&gt;의 소유권, 권한, 파일 종류 데이터를 공유하고, Data Block도 같은 공간을 바라보게 됩니다.반대로 심볼릭링크로 생성할 경우 새로운 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode2&lt;/code&gt;를 생성하고 해당 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode2&lt;/code&gt;의 Data Block은 파일 데이터가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Filename&lt;/code&gt;의 주소를 저장하고 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Link Data&lt;/code&gt;(파일포인터)입니다(실제 데이터를 저장하고 있지 않습니다). Windows의 바로가기 아이콘은 심볼릭 링크에 해당합니다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln &lt;/span&gt;basefile hardlink &lt;span class=&quot;c&quot;&gt;# 하드링크 파일 생성&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ln&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; basefile softlink &lt;span class=&quot;c&quot;&gt;# 소프트링크(심볼릭링크) 생성&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-il&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# inode 번호를 가장 앞에 출력함 &lt;/span&gt;
4063514 &lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 2 root root 60 7월 16 15:31 basefile
4063514 &lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 2 root root 60 7월 16 15:31 hardlink &lt;span class=&quot;c&quot;&gt;# basefile과 같은 inode&lt;/span&gt;
4063516 lrwxrwxrwx 1 root root 8  7월 16 15:33 softlink -&amp;gt; basefile &lt;span class=&quot;c&quot;&gt;# basefile과 inode가 다르다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;softlink&lt;/code&gt; 파일은 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;basefile&lt;/code&gt;의 위치로 링크되기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;basefile&lt;/code&gt;을 이동 시키면 소프트링크는 유지되지 않습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hardlink&lt;/code&gt;는 파일포인터를 이용하지 않고 같은 inode를 바라보기때문에 링크가 유지됩니다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mv &lt;/span&gt;basefile ../ &lt;span class=&quot;c&quot;&gt;# basefile 위치 변경 (상위 디렉터리로 이동)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;hardlink &lt;span class=&quot;c&quot;&gt;# 링크 확인&lt;/span&gt;
파일 링크 연결 확인
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;softlink &lt;span class=&quot;c&quot;&gt;# 링크 확인&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt;: softlink: 그런 파일이나 디렉터리가 없습니다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;basefile&lt;/code&gt;을 원래 위치로 복귀시키면 소프트링크가 작동하는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; ../basefile &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 현재 디렉터리로 이동 &lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;softlink &lt;span class=&quot;c&quot;&gt;# 링크 확인&lt;/span&gt;
파일 링크 연결 확인
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;특수-권한special-permissions에-대해서&quot;&gt;특수 권한(Special Permissions)에 대해서&lt;/h1&gt;
&lt;p&gt;리눅스의 특수 권한은 세 가지가 있습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;SUID&lt;/li&gt;
  &lt;li&gt;GUID&lt;/li&gt;
  &lt;li&gt;sticky bit&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;특수 권한은 파일의 소유자(owner)가 아닌 user에게 더 높은 권한을 부여하지 않고도 해당 파일을 실행할 수 있도록 허용하기 위해 탄생했습니다. User &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt;가 생성한 파일을 다른 유저가 실행하고자 할 때 가장 간단한 해결책은 무엇일까요? 혼자서 사용하는 리눅스 환경이라면 단순하게  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt;  커맨드를 입력하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;  계정의 권한을 획득하여 실행할 수 있을 것입니다. 그러나 여러 멤버들과 함께 사용하는 리눅스 환경에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 커맨드에 대한 권한이 없는 경우가 더 많을 뿐 아니라 설령 허용된다고 하더라도 모든 문제를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;  권한으로 해결하고자하는 것은 위험한 발상입니다. 결국 모든 사용자가  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;  권한을 요구하게 되고 이는 리눅스의 사용자/그룹/파일 관리 시스템에 위배되는 현상이기 때문입니다. 이러한 현상을 해결하기 위해 등장한 것이 &lt;strong&gt;특수 권한&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;h2 id=&quot;suid&quot;&gt;SUID&lt;/h2&gt;

&lt;p&gt;SUID(&lt;strong&gt;S&lt;/strong&gt;et Owner &lt;strong&gt;U&lt;/strong&gt;ser &lt;strong&gt;ID&lt;/strong&gt;)는 user가 파일을 실행할 수 있도록 설정합니다.  구체적으로, SUID를 설정하게 되면 user는 해당 파일을 실행할 때, owner와 같은 권한을 갖는 채로 실행이 가능해집니다.&lt;/p&gt;

&lt;p&gt;만약에  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;가 어떤 파일을 생성하였고, 해당 파일의 실행 권한이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 에게만 있다고 가정해봅시다. 아래와 같은 경우가 그에 해당합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gyuhoonkim&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt; 
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 root root 0 7월 15 16:11 testfile1
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 root root 0 7월 15 16:11 testfile2
gyuhoonkim&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;testfile1
&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;testfile1&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;: Permission denied
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 외의 계정은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testfile1&lt;/code&gt;을 읽을 수는 있지만, 실행할 수는 없습니다. 이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;suid&lt;/code&gt; 를 설정하게되면,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 외의 계정에서도 위 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testfile1&lt;/code&gt; 을 실행할 수 있습니다. 실행하는 순간  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;의 권한을 획득하기 때문입니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gyuhoonkim&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo
&lt;/span&gt;root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;4744 testfile1 &lt;span class=&quot;c&quot;&gt;# 실행권한 있음&lt;/span&gt;
root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;u+s testfile2 &lt;span class=&quot;c&quot;&gt;# 실행권한 없음&lt;/span&gt;
root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-rwsr--r--&lt;/span&gt; 1 root root 0 7월 15 16:11 testfile1
&lt;span class=&quot;nt&quot;&gt;-rwSr--r--&lt;/span&gt; 1 root root 0 7월 15 16:11 testfile2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;가 파일에 대해 실행권한(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;)를 가지고 있는 상태에서  SUID를 부여하게 되면 권한 표시에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;(소문자)로 표시됩니다. 반대로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 가 실행권한을 가지고 있지 않았다면  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt;(대문자)로 표시됩니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuhoonkim&lt;/code&gt;에서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;testfile1&lt;/code&gt;을 실행할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;su gyuhoonkim
gyuhoonkim&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;testfile1
실행 성공
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 권한 관리가 필요한 대표적인 경우는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passwd&lt;/code&gt;  명령어입니다.  user는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passwd&lt;/code&gt; 명령어로 패스워드를 설정/변경하는 경우에 자동으로  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt; 파일도 변경하게 됩니다.&lt;/p&gt;

&lt;p&gt;그런데 이 두 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;가 생성한 파일이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;권한이 없으면 수정할 수 없습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; /etc/passwd
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 root root 7868  8 11 15:44 /etc/passwd &lt;span class=&quot;c&quot;&gt;#644&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; /etc/shadow
&lt;span class=&quot;nt&quot;&gt;-rw-r-----&lt;/span&gt; 1 root root 7868  8 11 15:44 /etc/shadow &lt;span class=&quot;c&quot;&gt;# 640&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;가 아닌 계정(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gyuhoonkim&lt;/code&gt;)에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passwd&lt;/code&gt;를 실행하면,  위의 두 파일이 변경됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 가 아닌데도 위 두 파일을 변경할 수 있는 이유는  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passwd&lt;/code&gt;에 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; /usr/bin/passwd
&lt;span class=&quot;nt&quot;&gt;-rwsr-xr-x&lt;/span&gt; 1 root root 51096 8 11 15:44 /usr/bin/passwd&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 4755&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passwd&lt;/code&gt; 는 SUID가 설정된 명령어이기 때문에, 실행되는 순간 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;owner&lt;/code&gt;인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; 권한을 획득합니다. 따라서 일반 user가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;passwd&lt;/code&gt;를 실행하는 순간 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;권한을 가지고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/passwd&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt; 파일을 수정(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write&lt;/code&gt;)할 수 있게 되는 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;guid&quot;&gt;GUID&lt;/h2&gt;

&lt;p&gt;SUID와 비슷합니다. GUID가 설정된 파일은 실행할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group&lt;/code&gt;의 권한으로 실행됩니다. 만약 GUID가 설정된 디렉터리 하위에 디렉터리를 생성한다면, 생성된 디렉터리와 파일들은 설정된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group&lt;/code&gt;을 부여받게 됩니다.&lt;/p&gt;

&lt;p&gt;SUID와 비슷하지만, group에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt;를 표시합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
drwxr-xr-x 2 test1 test1 4096 6월 26 21:16 guid_dir1
drwxr-xr-x 2 test2 test2 4096 6월 26 21:16 guid_dir1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;2755 guid_dir1
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;g+x+s guid_dir2
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
drwxr-sr-x 2 test1 test1 4096 6월 26 21:16 guid_dir1
drwxr-Sr-x 2 test2 test2 4096 6월 26 21:16 guid_dir2
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# root 계정으로 변경&lt;/span&gt;
root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;guid_dir1
root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;test_dir1 
root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;test_file1
root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-l&lt;/span&gt;
drwxr-sr-x 2 root test1 4096 6월 26 22:16 dir1/ &lt;span class=&quot;c&quot;&gt;# Group owner가 test1&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-rw-r--r--&lt;/span&gt; 1 root test1 0    6월 26 22:16 test_file1 &lt;span class=&quot;c&quot;&gt;# Group owner가 test1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;GUID는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/mail&lt;/code&gt; 디렉터리 관리에 사용됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/mail&lt;/code&gt; 디렉터리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mail&lt;/code&gt; group owner를 가지고 있는데 이 하위에 생성되는 모든 디렉터리는  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mail&lt;/code&gt;  group owner를 갖도록 생성되어야 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mail&lt;/code&gt; 그룹을 통해 관리가 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ld&lt;/span&gt; /var/mail &lt;span class=&quot;c&quot;&gt;# GUID 셋팅 확인&lt;/span&gt;
drwxrwsr-x 2 root mail 4096 6월 26 22:30 /var/mail 
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;useradd &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; test3
&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ld&lt;/span&gt; /var/mail/test3 &lt;span class=&quot;c&quot;&gt;# Group Onwer가 mail로 생성되었음&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-rw-rw----&lt;/span&gt; 1 test3 mail 0 6월 26 22:40 /var/ail/test3 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;guid-1&quot;&gt;GUID&lt;/h2&gt;
&lt;h2 id=&quot;sticky-bit&quot;&gt;sticky bit&lt;/h2&gt;

&lt;p&gt;sticky bit는 디렉터리에 적용되는 옵션입니다. sticky bit가 설정되면, 설정된 디렉터리와 내부 파일에 접근할 수 있는 user는 자신이 생성한 파일만 삭제할 수 있고, 다른 user의 파일은 수정하거나 삭제할 수 없습니다. 이런 특징은 공유 폴더를 관리할 때에 사용됩니다. sticky bit가 설정된 디렉터리나 내부 파일들의 권한이 777로 설정되어 있다고 하더라도, sticky bit 옵션 때문에 삭제는 불가능합니다(생성은 가능합니다).&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ld&lt;/span&gt;
drwxr-xr-x 2 root root 4096 6월 26 23:00 dir1
drwxr-xr-x 2 root root 4096 6월 26 23:00 dir2
drwxr-xr-x 2 root root 4096 6월 26 23:00 dir3

&lt;span class=&quot;c&quot;&gt;# sticky bit 부여&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;1754 dir1 &lt;span class=&quot;c&quot;&gt;# Other의 e 권한 회수(100)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod &lt;/span&gt;o+t dir2
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +t dir3

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-ld&lt;/span&gt;
drwxr-xr-T 2 root root 4096 6월 26 23:00 dir1 &lt;span class=&quot;c&quot;&gt;# Other가 e권한 없는 경우 T로 표시&lt;/span&gt;
drwxr-xr-t 2 root root 4096 6월 26 23:00 dir2
drwxr-xr-t 2 root root 4096 6월 26 23:00 dir3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 특성은  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;와 같이 공유 폴더를 관리할 때 사용합니다. 공유폴더 내부에서는 누구나 파일을 생성할 수 있지만, 다른 user가 생성한 파일에 대해서 삭제/수정이 불가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;dir2
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;su test1
test1&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;testfile1
test1&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;testfile2

&lt;span class=&quot;c&quot;&gt;# test2 계정에서 확인&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;su test2
test2&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;tesetfile1
tesetfile1: failed to remove &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;tesetfile1&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;: 명령을 허용하지 않음
test2&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;testfile2
testfile2: failed to remove &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;testfile2&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;: 명령을 허용하지 않음

&lt;span class=&quot;c&quot;&gt;# root 계정에서 확인&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;su root
root&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;tesetfile1 &lt;span class=&quot;c&quot;&gt;# 삭제 성공&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# test1(파일을 생성한 계정)에서 확인&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;su test1
test1&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rm &lt;/span&gt;testfile2 &lt;span class=&quot;c&quot;&gt;# 삭제 성공&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[참고]&lt;br /&gt;
&lt;a href=&quot;https://cafe.naver.com/thisisLinux&quot;&gt;이것이 루분투 리눅스다(2017)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@1154_75881/what-is-the-difference-between-a-hard-link-and-a-symbolic-link-14db61df7707&quot;&gt;What is the difference between a hard link and a symbolic link?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://linuxhint.com/special-permissions-suid-guid-sticky-bit/&quot;&gt;Special Permissions: SUID, GUID, and sticky bit&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://eunguru.tistory.com/115&quot;&gt;[UNIX/Linux]특수 권한(setuid, setgid, sticky bit)&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="linux" />
      

      
        <summary type="html">Linux 사용자 관리, 파일속성 그리고, 특수권한에 대해서 알아봅니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">나의 첫 컨트리뷰션(Retrospect on my first contribution)</title>
      <link href="https://gyuhoonk.github.io/first-contributor" rel="alternate" type="text/html" title="나의 첫 컨트리뷰션(Retrospect on my first contribution)" />
      <published>2022-11-05T22:30:00+09:00</published>
      <updated>2022-11-05T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/first-contributor</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/first-contributor">&lt;p&gt;오픈소스 컨트리뷰션 회고&lt;/p&gt;

&lt;h1 id=&quot;datahub&quot;&gt;DataHub&lt;/h1&gt;

&lt;p&gt;저의 첫 컨트리뷰션의 대상이 된 오픈소스는 &lt;a href=&quot;https://datahubproject.io/&quot;&gt;DataHub&lt;/a&gt;입니다. DataHub는 데이터 디스커버리 플랫폼입니다. &lt;a href=&quot;https://demo.datahubproject.io/&quot;&gt;Demo 사이트&lt;/a&gt; 에 접속해보시면 어떤 역할을 하는 플랫폼인지 직관적으로 이해할 수 있습니다. 수 많은 데이터들이 다양한 데이터베이스에 저장되고, 데이터베이스 내에서도 수 많은 테이블로 저장되고 있습니다. DataHub는 이러한 데이터들의 메타데이터를 한 곳에 모아 한눈에 볼 수 있는 기능을 제공합니다.&lt;/p&gt;

&lt;p&gt;저는 DataHub를 사내에 도입하는 과정에서 수정이 필요한 부분을 발견했습니다. 물론 사내에 도입하는 과정에서 해당 부분을 수정하여 배포하였습니다. 여기에 추가로 제가 수정한 부분을 컨트리뷰션해보았습니다!&lt;/p&gt;

&lt;h1 id=&quot;what-to-contribute&quot;&gt;What to Contribute?&lt;/h1&gt;

&lt;h2 id=&quot;1-typo-in-guide&quot;&gt;1. typo in guide&lt;/h2&gt;

&lt;p&gt;가장 먼저 컨트리뷰션 한 내용은 오타 수정입니다. DataHub는 Airflow의 DAG 메타 정보(tag, run list 등)를 입력받을 수 있습니다. 이를 위해서는 Airflow에 DataHub에서 개발한 라이브러리를 설치하고 Airflow와 DataHub를 연결하는 connection을 생성해야합니다.&lt;/p&gt;

&lt;p&gt;connection은 DataHub의 GMS 컴포넌트 혹은 DataHub와 연결된 Kafka 중 하나를 선택해야합니다. 저는 Kafka와 연결하기를 희망했고 이 과정에서 공식문서를 참고하여 수정을 진행했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/retrospect/datahub-typo1.png&quot; alt=&quot;typo1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;airflow.cfg&lt;/code&gt; 를 아래와 같이 수정했지만, Kafka와 연결되지 않았고 여전히 GMS와 연결되고 있었습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# airflow.cfg
[datahub]
datahub_conn_id = datahub_kafka_default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 config 파일을 수정하는 것이 맞는지 DataHub에서 운영하는 커뮤니티 채널 중 Slack에 문의했고, 개발자로부터 아래와 같은 답변을 받았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/retrospect/datahub-typo2.png&quot; alt=&quot;typo2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datahub_conn_id&lt;/code&gt;가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;conn_id&lt;/code&gt;로 입력한 결과 Airflow가 Kafka와 연결되는 것을 확인할 수 있었습니다. 즉시 수정이 가능한 간단한 부분이라 PR을 생성하여 문서 수정을 요청하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/retrospect/datahub-typo3.png&quot; alt=&quot;typo3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명백한 오타였고, 개발자와 나눈 대화를 첨부했기에 따로 질문 없이 거의 즉시 approval되어 반영되었습니다. 현재는 수정된 상태인 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/retrospect/datahub-typo4.png&quot; alt=&quot;typo4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-bug-fix&quot;&gt;2. bug fix&lt;/h2&gt;

&lt;h3 id=&quot;problem&quot;&gt;Problem&lt;/h3&gt;

&lt;p&gt;두번째 케이스는 위보다는 조금 복잡합니다. Datahub Usage Analytics, Data Landscape Summary가 문제였습니다. 먼저, Datahub Usage Analytics는 DataHub 유저 로그를 트래킹하여 분석 결과를 제공합니다. &lt;a href=&quot;https://demo.datahubproject.io/analytics&quot;&gt;analytics 탭&lt;/a&gt;에서 확인할 수 있는데, 접속한 유저수, 검색량, 검색 쿼리, 액션과 같은 데이터를 제공합니다. Data Landscape Summary 역시 analytics 탭에 접속하여 확인해야하는데 해당 기능이 제공하는 정보는 현재 DataHub에서 관리되고 있는 메타데이터에 대한 개요(summary)를 보여줍니다.&lt;/p&gt;

&lt;p&gt;위 2개의 기능은  모두 analytics 탭을 통해 접근하여 확인해야한다는 공통점이 있지만, 개발자의 입장에서 볼 때 서로 관련이 있는 기능은 아닙니다.&lt;/p&gt;

&lt;p&gt;DataHub Usage Anlytics의 경우에는 배포 시에 helm chart에서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global.datahub_analytics_enabled&lt;/code&gt; 을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;로 셋팅하는 경우에만 유저 트래킹을 할 수 있습니다. 해당 옵션이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;로 설정되면 ElasticSearch 내부에서  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_stream&lt;/code&gt; 기능을 사용하는 인덱스(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datahub_usage_event&lt;/code&gt;)를 생성하여 해당 인덱스로부터 대쉬보드에 정보를 뿌려줍니다.&lt;/p&gt;

&lt;p&gt;반대로 Data Landscape Summary는 사용을 위해 따로 기능이 필요하지 않습니다. 이미 ingestion이 완료된(DataHub에 주입이 완료된) 메타데이터들을 바탕으로 어떤 소스로부터 몇 개의 메타데이터가 존재하는 지를 보여주는 기능이기 때문에 ElasticSearch와 관련이 없고, 단지 MySQL에 저장된 정보를 참고할 뿐입니다.&lt;/p&gt;

&lt;p&gt;저는 DataHub Usage Analytics 기능을 사용하길 원치 않았습니다. 제가 사용하는 ElasticSearch에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_streams&lt;/code&gt;가 지원되지 않았기 때문에 사용이 불가능했다가 정확한 표현입니다. DataHub Usage Analytics 기능을 사용하지 않기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global.datahub_analytics_enabled&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정했을 때 제가 의도치 않은 버그가 발생했습니다. analytics 탭을 누르면 아예 에러 코드가 발생하고, Data Landscape Summary도 확인이 불가능했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/retrospect/datahub-bugfix-error.png&quot; alt=&quot;error&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cause&quot;&gt;Cause&lt;/h3&gt;

&lt;p&gt;이러한 문제의 원인은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global.datahub_analytcis_enabled&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정할 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datahub_usage_event&lt;/code&gt; 라는 인덱스를 생성하지 않는데 프론트엔드의 구현에서는 analytics 탭을 클릭할 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datahub_usage_event&lt;/code&gt; 를 반드시 검색하도록 설정되어있기 때문이었습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Caused by: org.elasticsearch.ElasticsearchStatusException: Elasticsearch exception[type=index_not_found_exception, reason=no such index [datahub_usage_event]]                                                                                                                                                     
     at org.elasticsearch.rest.BytesRestResponse.errorFromXContent(BytesRestResponse.java:187)                                                               
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 구현은 문제가 있다고 생각했습니다. 유저 트래킹 기능을 사용하지 않더라도 Data LandScape Smmary은 확인할 수 있어야합니다. 둘은 독립된 기능으로 서로 영향을 주고 받지 않기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;여러 가지 해결책이 있을 수 있겠으나 제가 생각한 가장 간단한 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global.datahub_analytics_enabled&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;로 설정되었을 때에도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datahub_usage_event&lt;/code&gt; 를 생성하는 것입니다. 해당 인덱스는 어떤 데이터를 저장하지도 않고, 데이터를 fetch할 일도 없으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_streams&lt;/code&gt; 도 사용하지 않고  dummy index를 생성했습니다. 이렇게 dummy로 인덱스를 생성했더니 analytics 탭에 접속했을 때 에러도 발생하지 않고 data landscape summary도 확인할 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;contribute&quot;&gt;contribute&lt;/h3&gt;

&lt;p&gt;확인된 내용을 바탕으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker/elasticsearch-setup/create-indices.sh&lt;/code&gt; 파일을 수정하여 커밋했습니다. DataHub 개발자는 본인이 이해한 내용이 맞는지, 왜 해당 기능이 필요한 것인지, 왜 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data_streams&lt;/code&gt; 기능을 사용하지 못하는 경우가 존재하는지와 같은 내용을 질문했고 코멘트를 받을 때마다 열심히 답변했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/retrospect/datahub-bugfix-commit.png&quot; alt=&quot;contribute&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버그의 발견, 해결 방법을 생각해내고 구현해내는 것보다 개발자에게 이 기능이 필요한 이유와 어떤 이유 때문에 버그가 발생했는지를 설명하는 것이 더 어려웠던 것 같습니다. 그래도 포기하지 않고 끊임없이 질문해주시고 제 생각을 물어보려고 하는 모습을 보며 인류애를 느꼈습니다. 이러한 &lt;strong&gt;친절함&lt;/strong&gt;이 오픈소스가 성공하고 있는 이유가 아닐까요?&lt;/p&gt;

&lt;h3 id=&quot;approve&quot;&gt;approve&lt;/h3&gt;

&lt;p&gt;부족한 영어 실력을 가지고 열심히 해당 PR이 필요한 이유를 설명한 결과, 약 일주일 정도 걸려서 approve를 받고 해당 PR 내용이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v0.9.0&lt;/code&gt;에 포함되었습니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/retrospect/datahub-approve.png&quot; alt=&quot;approve&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;retrospect&quot;&gt;Retrospect&lt;/h1&gt;

&lt;p&gt;이미 성숙한 오픈소스에 컨트리뷰터로 기여하기는 어려울 것이라 생각합니다. 사용자가 많을수록 많은 버그가 발견되고 이미 많은 솔루션이 제시되었을 것이기 때문입니다. DataHub는 아직 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v1.0.0&lt;/code&gt;도 배포되지 않은 초기 오픈소스이기 때문에 아직 많은 버그들이 존재하며 버그를 발견해도 이를 해결하여 컨트리뷰트해주는 사람이 많지 않았기에 제게도 컨트리뷰션을 할 기회가 다가왔다고 생각합니다.&lt;/p&gt;

&lt;p&gt;컨트리뷰션 과정에서 나의 생각을 정리하는 것과 내가 겪고 있는 상황을 전달할 수 있는 커뮤니케이션 능력이 제 생각보다 훨씬 더 중요함을 깨달았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내가 제시하고 있는 솔루션은 어떤 논리적 흐름을 거쳤는지를 설명하는 것&lt;/li&gt;
  &lt;li&gt;이러한 논리적 흐름이 발생하게 된 상황/배경이 어땠는지 중요 포인트를 요약하여 정리하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컨트리뷰션 뿐만 아니라 개발자로서 일하고 성장하는데 있어서 매우 중요한 요소임을 직접 경험하게 된 것 같아 좋은 기회였습니다.&lt;/p&gt;

&lt;p&gt;다른 한가지 깨달은 것은 답답해하지 않고 상대방의 생각과 상황을 이해하기 위해 질문하는 태도입니다. 아마 제 PR에 assignee였던 pedro93은 조금 답답했었지 않을까요? 어색한 영어 문장으로 현재 상황을 애매하게 기술해놓았기 때문에 읽으면서 답답한 기분이었을 것 같습니다. 그래도 포기하지 않고, 계속 질문하며 PR이 필요한 이유와 이러한 생각을 하게 된 원인을 물어봐주는 그에게 너무나도 감사했습니다. 제가 받은 친절함을 다른 누구에게도 베풀고 싶다는 생각입니다.&lt;/p&gt;

&lt;p&gt;[참고]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://naver.github.io/OpenSourceGuide/book/BetterContribution/why-contribute-to-open-source.html&quot;&gt;컨트리뷰션 시작하기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[contributions]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/datahub-project/datahub/pull/5920&quot;&gt;docs: datahub_conn_id =&amp;gt; conn_id in Airflow Integration #5920&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/datahub-project/datahub/pull/5974&quot;&gt;fix(elasticsearch_index): create datahub_usage_event index where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;datahub_analytics_enabled&lt;/code&gt; set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; #5974&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="retrospect" />
      

      
        <summary type="html">오픈소스 컨트리뷰션 회고</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning Apache Spark 3 with Scala (Section8)</title>
      <link href="https://gyuhoonk.github.io/sparkscala8" rel="alternate" type="text/html" title="Learning Apache Spark 3 with Scala (Section8)" />
      <published>2022-08-27T22:30:00+09:00</published>
      <updated>2022-08-27T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/sparkscala8</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/sparkscala8">&lt;p&gt;Learning Apache Spark 3 with Scala (Section8 -Spark Streaming)&lt;/p&gt;

&lt;h1 id=&quot;spark-streaming&quot;&gt;Spark Streaming&lt;/h1&gt;

&lt;p&gt;한 번에 많은 데이터를 처리하는 Batch Process와 달리 Streaming은 실시간으로 유입되는 데이터를 모니터링하고 처리합니다. 대표적으로 웹사이트, 서버에서 발생하는 로그 데이터 처리가 Streaming에 해당합니다. 실시간으로 데이터를 처리하는 것 뿐 아니라, 유입되는 데이터를 특정 간격 단위(interval, window)로 계산(aggregate)하고 분석(analyze)할 것입니다.&lt;/p&gt;

&lt;p&gt;Streaming에서 데이터는 끊임없이 유입됩니다. 따라서  streaming data는 로우 파일(raw file)로 유입되지 않을 수 있습니다. TCP 데이터를 받는 포트, Amazon의 Kinesis, HDFS와 같은 분산 처리 시스템, Kafka, Flume과 같이 다양한 데이터 소스들로부터 발생하는 데이터를 처리할 수 있어야합니다.&lt;/p&gt;

&lt;p&gt;Spark Streaming은 이러한 모든 데이터 소스를 통합(integrate)하고, 보내지는 데이터를 분석(analyze)할 수 있습니다. 뿐만 아니라 데이터를 변형(transform)하여 다른 데이터 소스로 전송할 수도 있습니다. 대부분의 경우 로그 데이터를 가져와서, 특정 정보를 추출하고, 원하는 곳에 저장하는 케이스일 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;checkpoint&quot;&gt;Checkpoint&lt;/h2&gt;

&lt;p&gt;Spark Streaming의 가장 강력한 기능은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkpoint&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkpoint&lt;/code&gt; 는 fault tolerance를 위해 제공되는 기능입니다. 만약 streaming을 실행중인 클러스터가 다운되거나, streaming이 다운된다고 가정해봅시다. 이러한 경우에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;checkpoint&lt;/code&gt; 는 자동으로 다시 시작해야할 지점을 선택해줍니다.&lt;/p&gt;

&lt;h1 id=&quot;dstream-api&quot;&gt;DStream API&lt;/h1&gt;

&lt;p&gt;Spark Steaming은 DStream에서 시작되었습니다. DStream은 RDD에 기반한 API입니다. RDD에 기반하고 있다는 특징 때문에, DStream은 microbatch와 같은 작업에 특화되어있습니다. 즉, RDD로 표현되는 데이터 덩어리(chunks of data)를 다루고 처리할 수 있습니다. 이러한 작업은 data field나 row-by-row같은 방법으로 작동하지 않습니다. microbatch를 통해 데이터를 한 덩어리(chunk)로 만듭니다.&lt;/p&gt;

&lt;p&gt;그러나 현재 DStream은 잘 사용되지 않습니다. 최근 Application들이 즉각적인 데이터 처리를 지원하는 데에 비해 몇 초 정도의 지연이 있지만 이러한 부분이 문제가 되는 것은 아닙니다. DStream을 사용하지 않게 된 가장 큰 이유는 시간이 지나며 Spark Stream의 인터페이스로부터 배척되었기 때문입니다. DStream보다 최신 API가 등장했고 이에 따라 Dstream은 사용하지 않는 추세입니다.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;stream&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StreamingContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Seconds&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lines&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;socketTextStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8888&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;errors&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lines&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;error&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// start streaming&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;streama&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;awaitTermination&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait for termination&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DStream에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SparkContext&lt;/code&gt;가 아니라, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StreamingContext&lt;/code&gt;를 선언합니다. 위 예시의 경우 1초에 한번 씩, job을 처리하도록 셋팅되었습니다. 즉 1초마다 microbatch를 실행합니다.&lt;/p&gt;

&lt;p&gt;1초마다 microbatch는 localhost의 8888 포트로 텍스트 데이터를 전송합니다. 이때, 에러가 발생하는 경우 필터링하여 에러가 있는 텍스트 라인을 출력하고 있습니다.&lt;/p&gt;

&lt;p&gt;위 코드는 하나의 데이터 청크(a single chunk of data)를 처리하지 않습니다. 반복적으로 1초마다 유입되는 데이터들을 전송하고, 필터링하는 과정을 거칩니다. DStream에서 microbatch마다 처리하는 RDD는 유입되는 데이터의 하나의 작은 청크(one little chunk)입니다.&lt;/p&gt;

&lt;h2 id=&quot;window&quot;&gt;Window&lt;/h2&gt;

&lt;p&gt;Windowed operations을 사용하면, 다수의 배치로부터 발생한 결과를 결합시킬 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;window(), reduceByWindow(), reduceByKeyAndWindow()&lt;/code&gt;와 같은 함수가 존재하고, 이들을 이용하여 일정 시간 동안의 데이터를 reduce할 수 있습니다. 몇 분, 몇 시간, 며칠과 같은 기간 동안의 데이터를 모아 reduce시킵니다. 기본적으로 window size는 batch와 일치할 필요가 없습니다. batch보다 클 수도 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;updatestatebykey&quot;&gt;updateStateByKey&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;updateStateByKey()&lt;/code&gt;를 이용하면 시간이 흘러도, 많은 배치 작업들 간의 스테이트(state)를 유지할 수 있습니다. 따라서, window, batch에 따른  running state를 추적해야한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;updateStateByKey()&lt;/code&gt;를 사용해야합니다. count가 필요한 경우가 대표적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;updateStateByKey()&lt;/code&gt;가 사용되는 예입니다.&lt;/p&gt;

&lt;h1 id=&quot;structrued-streaming&quot;&gt;Structrued Streaming&lt;/h1&gt;

&lt;p&gt;DStream이 Spark의 오리지날 스트리밍 API이긴 하지만, 최근에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Structured Streaming&lt;/code&gt; 이 주로 사용되고 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Structured Streaming&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataSets&lt;/code&gt;를 사용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataSets&lt;/code&gt;를 기반으로 스트리밍 작업을 구현하기 때문에 쿼리를 작성하여 실행할 수도 있습니다. 또한 새로운 정보가 들어올 때마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataSets&lt;/code&gt;에 실시간으로  row를 추가하는 방식으로 작업을 단순화시킬 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Structured Streaming&lt;/code&gt;에서 다루는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataSets&lt;/code&gt;는 지금까지 다루었던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataSet&lt;/code&gt;과 큰 차이가 없습니다. 따라서 지금까지 배웠던 API를 배치 작업에 거의 그대로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;코드로 이를 구현하는 것 또한 매우 간단합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.read&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.readStream&lt;/code&gt;으로만 교체하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;inputDF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spark&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;readStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;s3://logs&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;inputDF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1 hour&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;writeStream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbc&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdcb:mysql//...&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 &lt;strong&gt;실시간으로&lt;/strong&gt; s3 storage로부터 log 파일을 읽어 들이고,  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;groupBy&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;window&lt;/code&gt;를 적용하여 그 결과를 mysql DB에 저장합니다. 이러한 작업을 작성하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataSet&lt;/code&gt;에서 사용했던 API가 그대로 사용되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;window-1&quot;&gt;Window&lt;/h2&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;dataset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;groupBy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;timestampColumnName&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;windowDuration&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;10 minutes&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slideDuration&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;5 minutes&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;col&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;columnWeAreGroupngBy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;window 설정을 위와 같은 포맷으로 지정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;[참고]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.udemy.com/course/best-scala-apache-spark/&quot;&gt;Learning Apache Spark 3 with Scala&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="scala" />
      

      
        <summary type="html">Learning Apache Spark 3 with Scala (Section8 -Spark Streaming)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Learning Apache Spark 3 with Scala (Section7)</title>
      <link href="https://gyuhoonk.github.io/sparkscala7" rel="alternate" type="text/html" title="Learning Apache Spark 3 with Scala (Section7)" />
      <published>2022-06-24T22:30:00+09:00</published>
      <updated>2022-06-24T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/sparkscala7</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/sparkscala7">&lt;p&gt;Learning Apache Spark 3 with Scala (Section7 - Machine Learning Library)&lt;/p&gt;

&lt;h1 id=&quot;machine-learning-in-spark&quot;&gt;machine learning in Spark&lt;/h1&gt;

&lt;h2 id=&quot;why-to-use-machine-learning-in-spark&quot;&gt;why to use machine learning in Spark&lt;/h2&gt;

&lt;p&gt;머신러닝 알고리즘을 적용해야할 데이터의 양이 1대의 PC가 처리할 수 있는 사이즈보다 큰 경우, Spark를 이용하여 머신러닝 알고리즘을 수행할 수 있습니다. spark에서 머신러닝 알고리즘을 실행하면, 각 클러스터의 데이터에 해당 머신러닝 알고리즘을 적용합니다. 이는 1대의 노트북이나 데스크탑에서 수행할 수 없는 대량의 데이터에 대한 머신러닝 작업을 가능하게 합니다.&lt;/p&gt;

&lt;p&gt;대부분의 머신러닝 알고리즘은 많은 GPU와 메모리를 지닌 단일 머신을 작동해야하는 방식(monolithic)이었습니다. Spark는 이와는 반대로 데이터를 여러대의 머신에 수평으로 전개하여 머신러닝 알고리즘을 적용합니다.&lt;/p&gt;

&lt;h3 id=&quot;gpu-in-spark&quot;&gt;GPU in Spark?&lt;/h3&gt;

&lt;p&gt;클러스터의 CPU만으로 처리할 수 없는 대용량의 데이터가 존재할 수 있습니다. 이런 경우에는 각 클러스터의 GPU까지 동원하며 클러스터 내부에서도 병렬 작업을 실행할 수 있도록 해야합니다. spark 3.x부터 GPU 가속을 사용할 수 있습니다(&lt;a href=&quot;https://www.nvidia.com/ko-kr/ai-data-science/spark-ebook/gpu-accelerated-spark-3/&quot;&gt;데이터 사이언스 가이드&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;machine-learning-packages-in-spark&quot;&gt;machine learning packages in Spark&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Feature Extraction
    &lt;ul&gt;
      &lt;li&gt;TF/IDF&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Basic statistics
    &lt;ul&gt;
      &lt;li&gt;Chi-Squared Test, Peason or Speaman corr, min, max, mean, var&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Linear Regression, Logistic Regression&lt;/li&gt;
  &lt;li&gt;Support Vector Machine&lt;/li&gt;
  &lt;li&gt;Naive Bayses Classifier&lt;/li&gt;
  &lt;li&gt;Decision Trees&lt;/li&gt;
  &lt;li&gt;K-means Clustering&lt;/li&gt;
  &lt;li&gt;Principal Component Analysis, Singular Value Decomposition&lt;/li&gt;
  &lt;li&gt;Recommendations using Alternating Least Squares(ALS)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;spark12-vs-spark3&quot;&gt;Spark1,2 vs Spark3&lt;/h1&gt;

&lt;p&gt;spark 버전에 따라 머신러닝 라이브러리에 변화가 있습니다. Spark1, 2 버전은 	&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.mllib&lt;/code&gt;을 기본으로 사용하고 있고, Spark3 버전은  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.ml&lt;/code&gt;을 기본으로 사용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.mllib&lt;/code&gt;은 spark3에서도 지원하기는 하지만, 개발이 중단되었고, 일부 기능도 작동하지 않습니다(&lt;strong&gt;The MLlib RDD-based API is now in maintenance mode.&lt;/strong&gt;).&lt;/p&gt;

&lt;h2 id=&quot;sparkmllib-in-spark12&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.mllib&lt;/code&gt; in Spark1,2&lt;/h2&gt;

&lt;p&gt;현재 관점에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.mllib&lt;/code&gt;은 구형 API입니다. 해당 API는 RDD를 사용합니다. 또한 특정 데이터 구조를 이용해 머신러닝 알고리즘을 수행했습니다.&lt;/p&gt;

&lt;h3 id=&quot;특정-데이터-구조&quot;&gt;특정 데이터 구조?&lt;/h3&gt;

&lt;p&gt;특정 데이터 구조는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vector&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Matrix&lt;/code&gt;를 의미합니다. 아래와 같이 분류됩니다(&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html&quot;&gt;mllib-data-types&lt;/a&gt;).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html#local-vector&quot;&gt;Local vector&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html#labeled-point&quot;&gt;Labeled point&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html#local-matrix&quot;&gt;Local matrix&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Distributed matrix
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html#rowmatrix&quot;&gt;RowMatrix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html#indexedrowmatrix&quot;&gt;IndexedRowMatrix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html#coordinatematrix&quot;&gt;CoordinateMatrix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/mllib-data-types.html#blockmatrix&quot;&gt;BlockMatrix&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.mllib.clustering.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;KMeans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;KMeansModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.mllib.linalg.Vectors&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Load and parse the data&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;textFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data/mllib/kmeans_data.txt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;parsedData&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;Vectors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;dense&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;toDouble&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Cluster the data into two classes using KMeans&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numClusters&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;numIterations&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;clusters&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;KMeans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;train&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parsedData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numClusters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numIterations&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RDD를 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Vector&lt;/code&gt;로 변경하여(parse) 클러스터링을 적용하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;newer-libsparkml-in-spark3&quot;&gt;newer Lib(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.ml&lt;/code&gt;) in Spark3&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.ml&lt;/code&gt;의 가장 큰 특징은 RDD가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataFrame&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dataset&lt;/code&gt;을 사용한다는 점입니다. 이를 통해 spark의 다른 컴포넌트(ex. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sparkSQL&lt;/code&gt;)와 데이터를 주고 받을 수 있습니다.   즉 &lt;strong&gt;상호운영성&lt;/strong&gt;을 확보할 수 있습니다. 예를 들어, SparkSQL로부터 학습 데이터를 추출하여 SparkML의 머신러닝 알고리즘을 실행하고, 실행 결과를 다시 SparkSQL로 처리할 수 있습니다. 이러한 동작이 가능한 이유는 모든 컴포넌트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataFrame&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dataset&lt;/code&gt;을 기본으로 채택하고 있기 때문입니다.&lt;/p&gt;

&lt;h1 id=&quot;examples&quot;&gt;Examples&lt;/h1&gt;

&lt;p&gt;아래 예시들은 &lt;a href=&quot;https://www.udemy.com/course/best-scala-apache-spark/&quot;&gt;Learning Apache Spark 3 with Scala&lt;/a&gt; 강좌에서 제공되는 예제 코드들을 옮겨놓았습니다.&lt;/p&gt;

&lt;h2 id=&quot;recommendation&quot;&gt;Recommendation&lt;/h2&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark._&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.ml.recommendation._&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;als&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ALS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setMaxIter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setRegParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setUserCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;userID&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setItemCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;movieID&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setRatingCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rating&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;als&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ratings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;toInt&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;toDF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;userID&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;recommendations&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;recommendForUserSubset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;linear-regression&quot;&gt;Linear regression&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vectorAssembler&lt;/code&gt;를 이용하여 데이터를 가공한 뒤 알고리즘을 적용합니다.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark._&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; 
&lt;span class=&quot;nn&quot;&gt;org.apache.spark.ml.feature.VectorAssembler&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.ml.regression.LinearRegression&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Load Data&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;regressionSchema&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StructType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DoubleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;features_raw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DoubleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;dsRaw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;spark&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;read&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sep&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;schema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regressionSchema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;csv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data/regression.txt&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;RegressionSchema&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Transform&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;assembler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VectorAssembler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;setInputCols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;features_raw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)).&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;setOutputCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;features&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;assembler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dsRaw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;features&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Split&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;trainTest&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;randomSplit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;trainingDF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;trainTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testDF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;trainTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// Now create our linear regression model&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lir&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LinearRegression&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setRegParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// regularization &lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setElasticNetParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// elastic net mixing&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setMaxIter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// max iterations&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setTol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// convergence tolerance&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// Train the model using our training data&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trainingDF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// Now see if we can predict values in our test data.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Generate predictions using our linear regression model for all features in our &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// test dataframe:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fullPredictions&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testDF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// This basically adds a &quot;prediction&quot; column to our testDF dataframe.&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// Extract the predictions and the &quot;known&quot; correct labels.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;predictionAndLabel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fullPredictions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;prediction&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;label&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;decision-tree&quot;&gt;Decision Tree&lt;/h2&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.ml.feature.VectorAssembler&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.ml.regression.DecisionTreeRegressor&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// skip load data //&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;assembler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VectorAssembler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setInputCols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HouseAge&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;DistanceToMRT&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;NumberConvenienceStroes&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setOutputCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;features&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;assembler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dsRaw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PriceOfUnitArea&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;features&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;trainTest&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;df&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;randomSplit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;traningDF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;trainTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;testDF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;trainTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lir&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DecisionTreeRegressor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setFeaturesCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;features&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setLabelCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PriceOfUnitArea&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;lir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;fit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traingDF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fullPredictions&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testDF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;predictionAndLabel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;fullPredictions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;prediction&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;PriceOfUnitArea&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예시로 제공된 3개 모두 모델에 대한 평가를 하지 않고 있는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;org.apache.spark.ml.evaluation&lt;/code&gt;  내에 클래스를 통해 학습에 대한 평가를 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;org.apache.spark.ml.evaluation.RegressionEvaluator&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;evaluator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RegressionEvaluator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setMetricName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;rmse&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setLabelCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;PriceOfUnitArea&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;setPredictionCol&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;prediction&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;rmse&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;evaluator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;evaluate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fullPredictions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RMSE error = $rmse&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[참고]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.udemy.com/course/best-scala-apache-spark/&quot;&gt;Learning Apache Spark 3 with Scala&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/ml-guide.html&quot;&gt;Spark ML lib Gruide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.nvidia.com/ko-kr/ai-data-science/spark-ebook/gpu-accelerated-spark-3/&quot;&gt;데이터 사이언스 가이드&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="scala" />
      

      
        <summary type="html">Learning Apache Spark 3 with Scala (Section7 - Machine Learning Library)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">enableHiveSupport</title>
      <link href="https://gyuhoonk.github.io/enableHiveSupport" rel="alternate" type="text/html" title="enableHiveSupport" />
      <published>2022-06-16T22:30:00+09:00</published>
      <updated>2022-06-16T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/enableHiveSupport</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/enableHiveSupport">&lt;p&gt;Spark enableHiveSupport(Hive metaStore)&lt;/p&gt;

&lt;h1 id=&quot;hive-table-in-spark&quot;&gt;Hive Table in Spark&lt;/h1&gt;

&lt;p&gt;spark에서 Hive table에 접근할 수 있도록 설정하기 위해서 ‘enableHiveSupport()’를 주로 사용하는데요.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;spark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SparkSession&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enableHiveSupport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getOrCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;df&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
SELECT *
FROM default.test1
&quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enableHiveSupport()&lt;/code&gt;의 의미가 무엇인지 생각해보지 않았던 것 같아서 한번 조사해보았습니다.&lt;/p&gt;

&lt;p&gt;이에 대해 알기 위해서는 Hive Table Location에 대해서 먼저 알아야합니다.&lt;/p&gt;

&lt;h2 id=&quot;hive---table-location&quot;&gt;Hive - Table Location&lt;/h2&gt;

&lt;p&gt;예를 들어 defualt.test_1 이라는 테이블이 있다고 가정하면, 해당 테이블은 HDFS 상에서 ‘/usre/hive/warehouse/default.db/test_1’ 경로에 저장되어 있습니다.&lt;/p&gt;

&lt;p&gt;이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TABLE LOACTION&lt;/code&gt;이라고 합니다.&lt;/p&gt;

&lt;p&gt;나아가, PARTITIONED TABLE의 경우에는 해당 LOCATION 하위에 PARTITION DIR이 더 존재합니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;구분&lt;/th&gt;
      &lt;th&gt;TABLE&lt;/th&gt;
      &lt;th&gt;HDFS LOCATION&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Table&lt;/td&gt;
      &lt;td&gt;default.table1&lt;/td&gt;
      &lt;td&gt;/user/hive/warehouse/default.db/table1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Partitioned Table&lt;/td&gt;
      &lt;td&gt;default.table2 PARTITION (col1=a)&lt;/td&gt;
      &lt;td&gt;/user/hive/warehouse/default.db/table2/col1=a&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;우리가 Hive에 쿼리를 작성하여 테이블을 조회하는 것은 사실 HDFS에서 LOCATION에 존재하는 파일을 읽는 것입니다.&lt;/p&gt;

&lt;p&gt;따라서, 우리가 아래 쿼리를 실행하면&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;table1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hive는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default.table1&lt;/code&gt;에 해당하는 LOCATION에 저장된 파일로부터 데이터를 읽어 결과를 출력합니다. 즉, 아래 커맨드로 확인할 수 있는 파일들을 스캔합니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;hdfs dfs &lt;span class=&quot;nt&quot;&gt;-ls&lt;/span&gt; /user/hive/warehouse/default.db/table1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;hive-metastore&quot;&gt;Hive metaStore&lt;/h2&gt;

&lt;p&gt;그렇다면 TABLE의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOCATION&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PARTITION&lt;/code&gt; 정보 즉, &lt;strong&gt;hive metastore&lt;/strong&gt;는 어디에 저장하고 있을까요? &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hive-stie.xml&lt;/code&gt;에서 hive metastore의 저장 위치를 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;hive metastore는 1) 임베디드, 2) 로컬, 3) 원격 셋 중에 하나로 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래는 hive metastore를 3) 원격으로 저장했을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hive-site.xml&lt;/code&gt; 예시입니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /etc/hive/hive-site.xml
...
&amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;hive.metastore.uris&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;thrift://host.example:9083&amp;lt;/value&amp;gt;
 &amp;lt;/property&amp;gt; 
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host.example:9083&lt;/code&gt;에 hive metastore가 저장되어있음을 확인할 수 있습니다. 즉, 해당 경로에 hive table들의 location, partition 같은 메타 데이터들이 저장되어 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;enablehivesupport&quot;&gt;enableHiveSupport&lt;/h2&gt;

&lt;p&gt;spark의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enableHiveSupport()&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hive.metastore.uris&lt;/code&gt; 설정 값에 접근하여 hive metastore를 사용하겠다 라는 의미입니다.&lt;/p&gt;

&lt;p&gt;default로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hive-site.xml&lt;/code&gt;에서 정의된 값을 사용하고, 정의되어있지 않다면  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.sql.warehouse.dir&lt;/code&gt; 로 전달된 경로에서 metastore를 검색합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When working with Hive, one must instantiate SparkSession with Hive support, including connectivity to a persistent Hive metastore, support for Hive serdes, and Hive user-defined functions. Users who do not have an existing Hive deployment can still enable Hive support. When not configured by the hive-site.xml, the context automatically creates metastore_db in the current directory and creates a directory configured by &lt;strong&gt;spark.sql.warehouse.dir&lt;/strong&gt;, which defaults to the directory spark-warehouse in the current directory that the Spark application is started. Note that the hive.metastore.warehouse.dir property in hive-site.xml is deprecated since Spark 2.0.0. Instead, use spark.sql.warehouse.dir to specify the default location of database in warehouse. You may need to grant write privilege to the user who starts the Spark application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 정보를 종합해보면 spark가 hive table을 읽어오는 과정은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enableHiveSupport()&lt;/code&gt;를 선언한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sparkSession&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.sql&lt;/code&gt;을 이용하여 테이블(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default.test1&lt;/code&gt;)을 조회합니다.&lt;/li&gt;
  &lt;li&gt;spark는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hive-site.xml&lt;/code&gt;  혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spark.sql.warehouse.dir&lt;/code&gt; 에서 hive metastore가 저장된 경로를 참조합니다.&lt;/li&gt;
  &lt;li&gt;hive metastore로부터 해당 테이블의 경로(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/user/hive/warehouse/default.db/test1&lt;/code&gt;)를 알아냅니다.&lt;/li&gt;
  &lt;li&gt;이후 해당 테이블 위치(location)에서 파일(데이터)를 읽어옵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;따라서 아래 두 방법은 기본적으로 같은 동작을 수행합니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# query
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
SELECT *
FROM default.test1
&quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# file scan
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parquet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/user/hive/warehouse/default.db/test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Partitioned Table도 위와 크게 다르지 않습니다. 단지 table location에 partition column이 추가될 뿐입니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# query
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sql&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
SELECT *
FROM default.test1
WHERE col1 = 'a'
&quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# file scan
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parquet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/user/hive/warehouse/default.db/test1/col1=a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[참고]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wikidocs.net/28353&quot;&gt;5-메타스토어&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://spark.apache.org/docs/latest/sql-data-sources-hive-tables.html&quot;&gt;sql-data-sources-hive-tables&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="hadoop" />
      

      
        <summary type="html">Spark enableHiveSupport(Hive metaStore)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">merge vs. rebase</title>
      <link href="https://gyuhoonk.github.io/merge-rebase" rel="alternate" type="text/html" title="merge vs. rebase" />
      <published>2022-05-14T22:30:00+09:00</published>
      <updated>2022-05-14T22:30:00+09:00</updated>
      <id>https://gyuhoonk.github.io/merge-rebase</id>
      <content type="html" xml:base="https://gyuhoonk.github.io/merge-rebase">&lt;p&gt;merge와 rebase 비교하기&lt;/p&gt;

&lt;h1 id=&quot;merge--rebase&quot;&gt;Merge &amp;amp; Rebase&lt;/h1&gt;

&lt;p&gt;Git에서 브랜치를 합치는 두 가지 방법으로 merge와 rebase가 있습니다. 이 둘은 서로 다른 브랜치를 하나의 브랜치로 합친다는 공통점을 갖지만, 이외의 기능은 많은 차이를 보입니다.&lt;/p&gt;

&lt;h2 id=&quot;git-merge&quot;&gt;git merge&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Join two or more development histories together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by &lt;em&gt;git pull&lt;/em&gt; to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대상 브랜치의 커밋 내용을 현재 브랜치로 포함시킨다는 것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 의 가장 큰 특징입니다.  서로 다른 브랜치 간에서만 사용되는 것이 아니라, 저장소 간의 내용을 하나로 통합하는 경우에도 사용됩니다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git pull&lt;/code&gt;에서도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge&lt;/code&gt;를 이용합니다.&lt;/p&gt;

&lt;p&gt;git document는 아래와 같은 상황을 예시로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 를 설명합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      A---B---C topic
     /
D---E---F---G master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt;의 공통 조상이 되는 commit인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; 를 &lt;strong&gt;base&lt;/strong&gt;라고 부릅니다.&lt;/p&gt;

&lt;p&gt;현재 브랜치(current branch)가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 일 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge topic&lt;/code&gt; 을 실행하면, 아래와 같은 브랜치 히스토리가 생성됩니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout master
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git merge topic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      A---B---C topic
     /         \
D---E---F---G---H master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt;로부터 현재 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt; 브랜치의 current commit인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt;까지의 모든 변화(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-A-B-C&lt;/code&gt;)를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치의 current commit이었던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt;로부터 재실행합니다. 그리고 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;/code&gt; 라는 commit으로 생성합니다.&lt;/p&gt;

&lt;p&gt;이 때, 충돌(conflict)이 발생하게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 를 입력한 사용자는 충돌을 해결하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt; 를 이어가거나(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge --continue&lt;/code&gt;), 이전 상태로 되돌려야만 합니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge --abort&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;git-rebase&quot;&gt;git rebase&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rebase&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;upstream&amp;gt;, &amp;lt;branch&amp;gt;&lt;/code&gt;를 명시할 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 옵션은 명시하지 않으면 현재 명령어를 실행하는 브랜치(current branch)로 입력됩니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git rebase &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Reapply commits on top of another base tip&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[branch]&lt;/code&gt; is specified, &lt;em&gt;git rebase&lt;/em&gt; will perform an automatic &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git switch [branch]&lt;/code&gt; before doing anything else. Otherwise it remains on the current branch. All changes made by commits in the current branch but that are not in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[upstream]&lt;/code&gt; are saved to a temporary area.The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[upstream]&lt;/code&gt; are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[upstream]&lt;/code&gt;에 존재하지 않고, current branch(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[branch]&lt;/code&gt;)에 존재하는 commit은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;patch&lt;/code&gt;라는 임시 공간에 저장됩니다.  이후 해당 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;patch&lt;/code&gt;에 저장되있는 commit은 &lt;strong&gt;순서대로&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upstream&lt;/code&gt;의 current commit에서부터 적용됩니다. 이 과정은 공통 commit인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt; 를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upstream의&lt;/code&gt; current commit으로 변경하는 작업으로 이해할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      A---B---C topic
     /
D---E---F---G master 위와 같은 상황에서 아래 명령어를 실행하면, `topic` 브랜치의 base를  `master` 의 current commit `G` 로 변경합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout topic
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git rebase master &lt;span class=&quot;c&quot;&gt;# git rebase master topic&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;              A'--B'--C' topic
             /
D---E---F---G master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;current branch인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt; 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E-A-B-C&lt;/code&gt; 커밋들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;patch&lt;/code&gt; 에 잠시 저장되어 있다가, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G&lt;/code&gt; 에서부터  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;patch&lt;/code&gt;의 커밋 내용들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치에 &lt;strong&gt;순서대로&lt;/strong&gt; 적용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A-B-C&lt;/code&gt;를  &lt;strong&gt;한번에&lt;/strong&gt; 적용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;G--H&lt;/code&gt; 로 commit했던 것과 다른 부분입니다.&lt;/p&gt;

&lt;p&gt;이 때, 만약 upstream(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;matser&lt;/code&gt;)의 커밋 중 일부가 branch(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;)의 커밋 내용을 포함하고 있는 경우, 해당 커밋 내용은 건너뛰고(skipped) 진행됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       A---B---C topic
      /
 D---E---A'---F master
 # A in topic is same to A' in master 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;               B'---C' topic
              /
D---E---A'---F master
# A in topic is skipped when `git rebase master`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나의 브랜치(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;upstream&lt;/code&gt;)로 부터 여러 개의 브랜치가 생성되었을 때, rebase는 이를 간결하게 표현해 줄 수 있습니다. 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--onto&lt;/code&gt;옵션을 이용합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The current branch is reset to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[upstream]&lt;/code&gt;, or [newbase] if the –onto option was supplied. This has the exact same effect as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git reset --hard &lt;/code&gt;[upstream]`` (or [newbase]). ORIG_HEAD is set to point at the tip of the branch before the reset.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;–onto [newbase]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Starting point at which to create the new commits. If the –onto option is not specified, the starting point is &lt;upstream&gt;. May be any valid commit, and not just an existing branch name.&lt;/upstream&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;o---o---o---o---o  master
     \
      o---o---o---o---o  next
                       \
                        o---o---o  topic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약   &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;의 변화 내용만을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 에 병합하고 싶다면 우리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치로부터 분화(forked)된 것으로 변경해야합니다. rebase의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--onto&lt;/code&gt; 옵션을 이용하면  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topcic&lt;/code&gt; 의 base branch를  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt;로 변경할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git rebase &lt;span class=&quot;nt&quot;&gt;--onto&lt;/span&gt; master next topic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;newbase인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치로부터 새로운 커밋들을 rebase하게 됩니다. 이 경우, topic이 master로부터 forked되지 않았으므로 수정되게 됩니다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; 브랜치가  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;topic&lt;/code&gt;의 base로 변경됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;o---o---o---o---o  master
    |            \
    |             o'--o'--o'  topic
     \
      o---o---o---o---o  next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래의 경우처럼 브랜치 간 관계가 복잡한 경우에도 rebase를 이용하면 관계를 단순하게 조작할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                        H---I---J topicB
                       /
              E---F---G  topicA
             /
A---B---C---D  master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git rebase &lt;span class=&quot;nt&quot;&gt;--onto&lt;/span&gt; master topicA topicB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;             H'--I'--J'  topicB
            /
            | E---F---G  topicA
            |/
A---B---C---D  master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;purpose&quot;&gt;Purpose&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rebase&lt;/code&gt;는 두 개 이상의 브랜치를 합친다는 공통점은 있지만 동작 방식과 그 결과는 다릅니다. 따라서 목적에 따라 다르게 사용해야합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;git-rebase-1&quot;&gt;Git Rebase&lt;/h4&gt;

  &lt;ul&gt;
    &lt;li&gt;Streamlines a potentially complex history.&lt;/li&gt;
    &lt;li&gt;Avoids merge commit “noise” in busy repos with busy branches.&lt;/li&gt;
    &lt;li&gt;Cleans intermediate commits by making them a single commit, which can be helpful for DevOps teams.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h4 id=&quot;git-merge-1&quot;&gt;Git Merge&lt;/h4&gt;

  &lt;ul&gt;
    &lt;li&gt;Simple and familiar.&lt;/li&gt;
    &lt;li&gt;Preserves complete history and chronological order.&lt;/li&gt;
    &lt;li&gt;Maintains the context of the branch.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rebase&lt;/code&gt;는 복잡한 히스토리를 단순화하는데 주요한 목적이 있으나, 이러한 과정에서 정확한 forked 정보는 소실될 수 있습니다. 또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;에 비해서 사용이 어렵고 복잡합니다.&lt;/p&gt;

&lt;p&gt;반대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge&lt;/code&gt;는 fork, commit, merge에 대한 모든 히스토리가 그대로 남아있어 추후에 트래킹에서의 이점이 있을 수 있습니다. 그러나 모든 히스토리가 남기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rebase&lt;/code&gt;에 비해 히스토리가 복잡해지는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;[참고]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://git-scm.com/docs/git-merge&quot;&gt;Git Document - merge&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://git-scm.com/docs/git-rebase&quot;&gt;Git Document - rebase&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://www.perforce.com/blog/vcs/git-rebase-vs-git-merge-which-better&quot;&gt;Git Rebase vs. Git Merge: Which Is Better?&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>GyuhoonK</name>
        
        
      </author>

      

      
        <category term="git" />
      

      
        <summary type="html">merge와 rebase 비교하기</summary>
      

      
      
    </entry>
  
</feed>
